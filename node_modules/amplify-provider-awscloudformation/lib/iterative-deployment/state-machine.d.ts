import { EventObject, State } from 'xstate';
export declare type DeploymentMachineOp = {
    stackTemplatePath: string;
    previousMetaKey?: string;
    parameters: Record<string, string>;
    tableNames: string[];
    stackName: string;
    capabilities?: string[];
    stackTemplateUrl: string;
    region: string;
    clientRequestToken?: string;
};
export declare type DeploymentMachineStep = {
    deployment: DeploymentMachineOp;
    rollback: DeploymentMachineOp;
};
export declare type DeployMachineContext = {
    deploymentBucket: string;
    region: string;
    stacks: DeploymentMachineStep[];
    currentIndex: number;
    errors?: StateMachineError[];
    previousDeploymentIndex?: number;
};
export declare type DeploymentMachineEvents = 'IDLE' | 'DEPLOY' | 'ROLLBACK' | 'INDEX' | 'DONE' | 'NEXT';
export declare type DeploymentMachineState = State<DeployMachineContext, {
    type: DeploymentMachineEvents;
}, DeployMachineSchema, {
    value: any;
    context: DeployMachineContext;
}>;
export declare type StateMachineError = {
    error: Error;
    stateValue: string;
    currentIndex: number;
};
export interface DeployMachineSchema {
    states: {
        idle: {};
        deploy: {
            states: {
                triggerDeploy: {};
                deploying: {};
                waitingForDeployment: {};
                waitForTablesToBeReady: {};
            };
        };
        rollback: {
            states: {
                triggerRollback: {};
                rollingBack: {};
                waitingForRollback: {};
                waitForTablesToBeReady: {};
            };
        };
        deployed: {};
        rolledBack: {};
        failed: {};
    };
}
export interface DeploymentRollbackSchema {
    states: {
        idle: {};
        preRollback: {
            states: {
                previousDeploymentReadyCheck: {};
                previousTableReadyCheck: {};
            };
        };
        rollback: {
            states: {
                enterRollback: {};
                triggerRollback: {};
                rollingBack: {};
                waitingForRollback: {};
                waitForTablesToBeReady: {};
            };
        };
        rolledBack: {};
        failed: {};
    };
}
interface DeployMachineEvent extends EventObject {
    type: DeploymentMachineEvents;
}
export declare type StateMachineHelperFunctions = StateMachineDeployHelperFunctions | StateMachineRollbackHelperFunctions;
export declare type StateMachineDeployHelperFunctions = {
    deploymentWaitFn: (stack: Readonly<DeploymentMachineOp>) => Promise<void>;
    deployFn: (stack: Readonly<DeploymentMachineOp>) => Promise<void>;
    rollbackFn: (stack: Readonly<DeploymentMachineOp>) => Promise<void>;
    rollbackWaitFn: (stack: Readonly<DeploymentMachineOp>) => Promise<void>;
    tableReadyWaitFn: (stack: Readonly<DeploymentMachineOp>) => Promise<void>;
    stackEventPollFn: (stack: Readonly<DeploymentMachineOp>) => () => void;
    startRollbackFn: (context: Readonly<DeployMachineContext>) => Promise<void>;
};
export declare type StateMachineRollbackHelperFunctions = Omit<StateMachineDeployHelperFunctions, 'deploymentWaitFn' | 'deployFn'> & {
    preRollbackTableCheck: (stack: Readonly<DeploymentMachineOp>) => Promise<void>;
};
export declare function createDeploymentMachine(initialContext: DeployMachineContext, helperFns: StateMachineDeployHelperFunctions): import("xstate").StateMachine<DeployMachineContext, DeployMachineSchema, DeployMachineEvent, {
    value: any;
    context: DeployMachineContext;
}>;
export declare function createRollbackDeploymentMachine(initialContext: DeployMachineContext, helperFns: StateMachineRollbackHelperFunctions): import("xstate").StateMachine<DeployMachineContext, DeploymentRollbackSchema, DeployMachineEvent, {
    value: any;
    context: DeployMachineContext;
}>;
export {};
//# sourceMappingURL=state-machine.d.ts.map