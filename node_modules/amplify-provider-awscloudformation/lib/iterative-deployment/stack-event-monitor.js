"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackEventMonitor = void 0;
const aws_logger_1 = require("../utils/aws-logger");
class StackEventMonitor {
    constructor(cfn, stackName, printer, options) {
        this.cfn = cfn;
        this.stackName = stackName;
        this.printer = printer;
        this.active = false;
        this.startTime = Date.now();
        this.activity = {};
        this.completedStacks = new Set();
        this.stacksBeingMonitored = [this.stackName];
        this.lastPolledStackIndex = 0;
        this.options = { pollDelay: 5000, ...options };
        this.logger = aws_logger_1.fileLogger('stack-event-monitor');
    }
    start() {
        this.active = true;
        this.printer.start();
        this.scheduleNextTick();
        return this;
    }
    async stop() {
        this.active = false;
        this.printer.stop();
        if (this.tickTimer) {
            clearTimeout(this.tickTimer);
        }
        await this.finalPollToEnd();
    }
    scheduleNextTick() {
        if (!this.active) {
            return;
        }
        this.tickTimer = setTimeout(() => this.tick(), this.options.pollDelay);
    }
    async tick() {
        if (!this.active) {
            return;
        }
        try {
            this.readPromise = this.readNewEvents();
            await this.readPromise;
            this.readPromise = undefined;
            if (!this.active) {
                return;
            }
            this.printer.print();
        }
        catch (e) {
            this.logger('scheduleNextTick', [])(e);
            if (e && e.code !== 'Throttling')
                e.message = 'Error occurred while monitoring stack:' + e.message;
            throw e;
        }
        this.scheduleNextTick();
    }
    async readNewEvents() {
        var _a;
        const events = [];
        this.lastPolledStackIndex = (this.lastPolledStackIndex + 1) % this.stacksBeingMonitored.length;
        const stackName = this.stacksBeingMonitored[this.lastPolledStackIndex];
        if (!stackName) {
            return;
        }
        try {
            let nextToken;
            let finished = false;
            while (!finished) {
                const response = await this.cfn
                    .describeStackEvents({
                    StackName: stackName,
                    NextToken: nextToken,
                })
                    .promise();
                const eventPage = (_a = response === null || response === void 0 ? void 0 : response.StackEvents) !== null && _a !== void 0 ? _a : [];
                for (const event of eventPage) {
                    if (event.Timestamp.valueOf() < this.startTime) {
                        finished = true;
                        break;
                    }
                    if (event.EventId in this.activity) {
                        finished = true;
                        break;
                    }
                    if (event.ResourceType === 'AWS::CloudFormation::Stack') {
                        this.processNestedStack(event);
                        continue;
                    }
                    events.push((this.activity[event.EventId] = event));
                }
                nextToken = response === null || response === void 0 ? void 0 : response.NextToken;
                if (nextToken === undefined) {
                    finished = true;
                }
            }
        }
        catch (e) {
            this.logger('readNewEvents', [])(e);
            if (e.code === 'ValidationError' && e.message === `Stack [${this.stackName}] does not exist`) {
                return;
            }
            if (e.code === 'Throttling') {
            }
            else {
                throw e;
            }
        }
        events.reverse();
        for (const event of events) {
            this.printer.addActivity(event);
        }
    }
    processNestedStack(event) {
        if (event.ResourceType === 'AWS::CloudFormation::Stack') {
            const physicalResourceId = event.PhysicalResourceId;
            const idx = this.stacksBeingMonitored.indexOf(physicalResourceId);
            if (idx >= 0 && event.ResourceStatus.endsWith('_COMPLETE') && physicalResourceId !== this.stackName) {
                this.stacksBeingMonitored.splice(idx, 1);
                this.completedStacks.add(physicalResourceId);
            }
            else if (!this.completedStacks.has(physicalResourceId)) {
                this.stacksBeingMonitored.push(physicalResourceId);
            }
        }
    }
    async finalPollToEnd() {
        if (this.readPromise) {
            await this.readPromise;
        }
        await this.readNewEvents();
        this.printer.print();
    }
}
exports.StackEventMonitor = StackEventMonitor;
//# sourceMappingURL=stack-event-monitor.js.map