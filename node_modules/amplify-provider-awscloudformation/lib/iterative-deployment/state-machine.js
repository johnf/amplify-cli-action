"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRollbackDeploymentMachine = exports.createDeploymentMachine = void 0;
const xstate_1 = require("xstate");
const helpers_1 = require("./helpers");
const actions_1 = require("xstate/lib/actions");
function createDeploymentMachine(initialContext, helperFns) {
    const machine = xstate_1.Machine({
        id: 'DeployManager',
        initial: 'idle',
        context: initialContext,
        states: {
            idle: {
                on: {
                    DEPLOY: {
                        target: 'deploy',
                        actions: actions_1.send('NEXT'),
                    },
                },
            },
            deploy: {
                id: 'deploy',
                initial: 'triggerDeploy',
                states: {
                    triggerDeploy: {
                        entry: xstate_1.assign(context => {
                            return {
                                ...context,
                                currentIndex: context.currentIndex + 1,
                            };
                        }),
                        on: {
                            NEXT: [{ target: '#deployed', cond: 'isDeploymentComplete' }, { target: 'deploying' }],
                        },
                    },
                    deploying: {
                        invoke: {
                            id: 'deploy-stack',
                            src: helpers_1.getDeploymentOperationHandler(helperFns.deployFn),
                            onDone: {
                                target: 'waitingForDeployment',
                            },
                            onError: {
                                target: '#rollback',
                                actions: xstate_1.assign(helpers_1.collectError),
                            },
                        },
                    },
                    waitingForDeployment: {
                        invoke: {
                            id: 'wait-for-deploy-stack',
                            src: helpers_1.getDeploymentOperationHandler(helperFns.deploymentWaitFn),
                            onDone: {
                                target: 'waitForTablesToBeReady',
                            },
                            onError: {
                                target: '#rollback',
                                actions: xstate_1.assign(helpers_1.collectError),
                            },
                        },
                        activities: ['deployPoll'],
                    },
                    waitForTablesToBeReady: {
                        invoke: {
                            id: 'wait-for-table-to-be-ready',
                            src: helpers_1.getDeploymentOperationHandler(helperFns.tableReadyWaitFn),
                            onDone: {
                                target: 'triggerDeploy',
                                actions: actions_1.send('NEXT'),
                            },
                            onError: {
                                actions: xstate_1.assign(helpers_1.collectError),
                            },
                        },
                    },
                },
            },
            rollback: {
                id: 'rollback',
                initial: 'waitForTablesToBeReady',
                invoke: {
                    id: 'enter-rollback',
                    src: helperFns.startRollbackFn,
                },
                states: {
                    triggerRollback: {
                        entry: xstate_1.assign((context) => {
                            return {
                                ...context,
                                currentIndex: context.currentIndex - 1,
                            };
                        }),
                        on: {
                            NEXT: [{ target: '#rolledBack', cond: 'isRollbackComplete' }, { target: 'rollingBack' }],
                        },
                    },
                    rollingBack: {
                        invoke: {
                            id: 'rollback-stack',
                            src: helpers_1.getRollbackOperationHandler(helperFns.rollbackFn),
                            onDone: {
                                target: 'waitingForRollback',
                            },
                            onError: {
                                target: '#failed',
                                actions: xstate_1.assign(helpers_1.collectError),
                            },
                        },
                    },
                    waitingForRollback: {
                        invoke: {
                            id: 'wait-for-deployment',
                            src: helpers_1.getRollbackOperationHandler(helperFns.rollbackWaitFn),
                            onDone: {
                                target: 'waitForTablesToBeReady',
                            },
                            onError: {
                                target: '#failed',
                                actions: xstate_1.assign(helpers_1.collectError),
                            },
                        },
                        activities: ['rollbackPoll'],
                    },
                    waitForTablesToBeReady: {
                        invoke: {
                            id: 'wait-for-table-to-be-ready',
                            src: helpers_1.getRollbackOperationHandler(helperFns.tableReadyWaitFn),
                            onDone: {
                                target: 'triggerRollback',
                                actions: actions_1.send('NEXT'),
                            },
                            onError: {
                                actions: xstate_1.assign(helpers_1.collectError),
                            },
                        },
                    },
                },
            },
            deployed: {
                id: 'deployed',
                type: 'final',
            },
            rolledBack: {
                id: 'rolledBack',
                type: 'final',
            },
            failed: {
                id: 'failed',
                type: 'final',
            },
        },
    }, {
        guards: {
            isDeploymentComplete: helpers_1.isDeploymentComplete,
            isRollbackComplete: helpers_1.isRollbackComplete,
        },
        activities: {
            deployPoll: helpers_1.getDeploymentActivityPollerHandler(helperFns.stackEventPollFn),
            rollbackPoll: helpers_1.getRollbackActivityPollerHandler(helperFns.stackEventPollFn),
        },
    });
    return machine;
}
exports.createDeploymentMachine = createDeploymentMachine;
function createRollbackDeploymentMachine(initialContext, helperFns) {
    const machine = xstate_1.Machine({
        id: 'DeployManager',
        initial: 'idle',
        context: initialContext,
        states: {
            idle: {
                on: {
                    ROLLBACK: {
                        target: 'preRollback',
                    },
                },
            },
            preRollback: {
                id: 'pre-rollback',
                initial: 'previousDeploymentReadyCheck',
                states: {
                    previousDeploymentReadyCheck: {
                        id: 'previous-deployment-ready-check',
                        invoke: {
                            src: helpers_1.getPreRollbackOperationHandler(helperFns.rollbackWaitFn),
                            onDone: { target: 'previousTableReadyCheck' },
                            onError: {
                                target: '#failed',
                                actions: xstate_1.assign(helpers_1.collectError),
                            },
                        },
                    },
                    previousTableReadyCheck: {
                        id: 'previous-table-ready-check',
                        invoke: {
                            src: helpers_1.getPreRollbackOperationHandler(helperFns.preRollbackTableCheck),
                            onDone: { target: '#rollback' },
                            onError: {
                                target: '#failed',
                                actions: xstate_1.assign(helpers_1.collectError),
                            },
                        },
                    },
                },
            },
            rollback: {
                id: 'rollback',
                initial: 'enterRollback',
                states: {
                    enterRollback: {
                        invoke: {
                            id: 'enter-rollback',
                            src: helperFns.startRollbackFn,
                            onDone: {
                                target: 'triggerRollback',
                                actions: actions_1.send('NEXT'),
                            },
                            onError: {
                                target: '#failed',
                                actions: xstate_1.assign(helpers_1.collectError),
                            },
                        },
                    },
                    triggerRollback: {
                        entry: xstate_1.assign((context) => {
                            return {
                                ...context,
                                currentIndex: context.currentIndex - 1,
                            };
                        }),
                        on: {
                            NEXT: [{ target: '#rolledBack', cond: 'isRollbackComplete' }, { target: 'rollingBack' }],
                        },
                    },
                    rollingBack: {
                        invoke: {
                            id: 'rollback-stack',
                            src: helpers_1.getRollbackOperationHandler(helperFns.rollbackFn),
                            onDone: { target: 'waitingForRollback' },
                            onError: {
                                target: '#failed',
                                actions: xstate_1.assign(helpers_1.collectError),
                            },
                        },
                    },
                    waitingForRollback: {
                        invoke: {
                            id: 'wait-for-deployment',
                            src: helpers_1.getRollbackOperationHandler(helperFns.rollbackWaitFn),
                            onDone: { target: 'waitForTablesToBeReady' },
                            onError: {
                                target: '#failed',
                                actions: xstate_1.assign(helpers_1.collectError),
                            },
                        },
                        activities: ['rollbackPoll'],
                    },
                    waitForTablesToBeReady: {
                        invoke: {
                            id: 'wait-for-table-to-be-ready',
                            src: helpers_1.getRollbackOperationHandler(helperFns.tableReadyWaitFn),
                            onDone: {
                                target: 'triggerRollback',
                                actions: actions_1.send('NEXT'),
                            },
                            onError: { actions: xstate_1.assign(helpers_1.collectError) },
                        },
                    },
                },
            },
            rolledBack: {
                id: 'rolledBack',
                type: 'final',
            },
            failed: {
                id: 'failed',
                type: 'final',
            },
        },
    }, {
        guards: { isRollbackComplete: helpers_1.isRollbackComplete },
        activities: { rollbackPoll: helpers_1.getRollbackActivityPollerHandler(helperFns.stackEventPollFn) },
    });
    return machine;
}
exports.createRollbackDeploymentMachine = createRollbackDeploymentMachine;
//# sourceMappingURL=state-machine.js.map