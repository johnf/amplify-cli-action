"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExistingIndexNames = exports.assertNotIntrinsicFunction = exports.removeGSI = exports.addGSI = exports.getGSIDetails = exports.MAX_GSI_PER_TABLE = void 0;
const cloudform_1 = require("cloudform");
const lodash_1 = __importDefault(require("lodash"));
exports.MAX_GSI_PER_TABLE = 20;
const getGSIDetails = (indexName, table) => {
    var _a;
    const gsis = (_a = table.Properties.GlobalSecondaryIndexes) !== null && _a !== void 0 ? _a : [];
    assertNotIntrinsicFunction(gsis);
    const indexItems = lodash_1.default.filter(gsis, {
        IndexName: indexName,
    });
    if (indexItems.length) {
        const addedGSI = indexItems[0];
        const keySchema = addedGSI.KeySchema;
        assertNotIntrinsicFunction(keySchema);
        const attributesUsedInKey = keySchema.reduce((acc, attr) => {
            acc.push(attr.AttributeName);
            return acc;
        }, []);
        const existingAttrDefinition = table.Properties.AttributeDefinitions;
        assertNotIntrinsicFunction(existingAttrDefinition);
        const attributeDefinition = lodash_1.default.filter(existingAttrDefinition, defs => {
            return attributesUsedInKey.includes(defs.AttributeName);
        });
        return { gsi: addedGSI, attributeDefinition: attributeDefinition };
    }
};
exports.getGSIDetails = getGSIDetails;
const addGSI = (index, table) => {
    var _a, _b;
    const updatedTable = lodash_1.default.cloneDeep(table);
    const gsis = (_a = updatedTable.Properties.GlobalSecondaryIndexes) !== null && _a !== void 0 ? _a : [];
    assertNotIntrinsicFunction(gsis);
    const existingIndices = exports.getExistingIndexNames(table);
    if (existingIndices.length + 1 > exports.MAX_GSI_PER_TABLE) {
        throw new Error(`DynamoDB ${table.Properties.TableName || '{UnNamedTable}'} can have max of ${exports.MAX_GSI_PER_TABLE} GSIs`);
    }
    const indexName = index.gsi.IndexName;
    assertNotIntrinsicFunction(indexName);
    if (existingIndices.includes(indexName)) {
        throw new Error(`An index with name ${indexName} already exists`);
    }
    gsis.push(index.gsi);
    updatedTable.Properties.GlobalSecondaryIndexes = gsis;
    const attrDefs = ((_b = updatedTable.Properties.AttributeDefinitions) !== null && _b !== void 0 ? _b : []);
    updatedTable.Properties.AttributeDefinitions = lodash_1.default.unionBy(attrDefs, index.attributeDefinition, 'AttributeName');
    return updatedTable;
};
exports.addGSI = addGSI;
const removeGSI = (indexName, table) => {
    const updatedTable = lodash_1.default.cloneDeep(table);
    const gsis = updatedTable.Properties.GlobalSecondaryIndexes;
    assertNotIntrinsicFunction(gsis);
    if (!gsis || gsis.length === 0) {
        throw new Error(`No GSIs are present in the table`);
    }
    const indexNames = gsis.map(g => g.IndexName);
    if (!indexNames.includes(indexName)) {
        throw new Error(`Table ${table.Properties.TableName || '{UnnamedTable}'} does not contain GSI ${indexName}`);
    }
    const attrDefs = updatedTable.Properties.AttributeDefinitions;
    assertNotIntrinsicFunction(attrDefs);
    const removedIndices = lodash_1.default.remove(gsis, { IndexName: indexName });
    assertNotIntrinsicFunction(removedIndices);
    const currentKeySchemas = gsis.reduce((acc, gsi) => {
        acc.push(...gsi.KeySchema);
        return acc;
    }, []);
    if (gsis.length == 0) {
        delete updatedTable.Properties.GlobalSecondaryIndexes;
    }
    if (removedIndices === null || removedIndices === void 0 ? void 0 : removedIndices.length) {
        const removedIndex = removedIndices[0];
        const removedKeySchema = removedIndex.KeySchema;
        assertNotIntrinsicFunction(removedKeySchema);
        const attrToRemove = lodash_1.default.differenceBy(removedKeySchema, currentKeySchemas, 'AttributeName');
        lodash_1.default.pullAllBy(attrDefs, attrToRemove, 'AttributeName');
    }
    return updatedTable;
};
exports.removeGSI = removeGSI;
function assertNotIntrinsicFunction(x) {
    if (x instanceof cloudform_1.IntrinsicFunction) {
        throw new Error('Intrinsic functions are not supported in KeySchema and GlobalSecondaryIndex');
    }
}
exports.assertNotIntrinsicFunction = assertNotIntrinsicFunction;
const getExistingIndexNames = (table) => {
    var _a;
    const gsis = (_a = table.Properties.GlobalSecondaryIndexes) !== null && _a !== void 0 ? _a : [];
    assertNotIntrinsicFunction(gsis);
    return gsis.reduce((acc, idx) => [...acc, idx.IndexName], []);
};
exports.getExistingIndexNames = getExistingIndexNames;
//# sourceMappingURL=dynamodb-gsi-helpers.js.map