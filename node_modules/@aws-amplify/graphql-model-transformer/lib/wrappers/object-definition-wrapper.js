"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnumWrapper = exports.InputObjectDefinitionWrapper = exports.ObjectDefinationWrapper = exports.FieldWrapper = exports.InputFieldWraper = exports.GenericFieldWrapper = exports.DirectiveWrapper = exports.ArgumentWrapper = void 0;
const graphql_1 = require("graphql");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const lodash_1 = require("lodash");
class ArgumentWrapper {
    constructor(argument) {
        this.serialize = () => {
            return {
                kind: 'Argument',
                name: this.name,
                value: this.value,
            };
        };
        this.name = argument.name;
        this.value = argument.value;
    }
}
exports.ArgumentWrapper = ArgumentWrapper;
class DirectiveWrapper {
    constructor(node) {
        this.arguments = [];
        this.serialize = () => {
            return {
                kind: 'Directive',
                name: this.name,
                arguments: this.arguments.map(arg => arg.serialize()),
            };
        };
        this.getArguments = (defaultValue) => {
            const argValues = this.arguments.reduce((acc, arg) => ({
                ...acc,
                [arg.name.value]: graphql_1.valueFromASTUntyped(arg.value),
            }), {});
            return lodash_1.merge(defaultValue, argValues);
        };
        this.name = node.name;
        this.arguments = (node.arguments || []).map(arg => new ArgumentWrapper(arg));
        this.location = this.location;
    }
}
exports.DirectiveWrapper = DirectiveWrapper;
class GenericFieldWrapper {
    constructor(field) {
        this.isList = () => {
            return graphql_1.isListType(this.type);
        };
        this.isNonNullable = () => {
            return this.type.kind === 'NonNullType';
        };
        this.makeNullable = () => {
            if (this.isNonNullable()) {
                this.type = this.type.type;
                return true;
            }
            return false;
        };
        this.makeNonNullable = () => {
            if (!this.isNonNullable()) {
                this.type = { kind: 'NonNullType', type: this.type };
                return true;
            }
            return false;
        };
        this.wrapListType = () => {
            if (!this.isList()) {
                this.type = {
                    kind: 'ListType',
                    type: this.type,
                };
            }
            return this;
        };
        this.unWrapListType = () => {
            if (!this.isList()) {
                this.type = this.type.type;
                return true;
            }
            return false;
        };
        this.getBaseType = () => {
            let node = this.type;
            while (node.kind === 'ListType' || node.kind === 'NonNullType') {
                node = node.type;
            }
            return node;
        };
        this.getTypeName = () => {
            return this.getBaseType().name.value;
        };
        this.isScalar = () => {
            const typeName = this.getTypeName();
            return Object.keys(graphql_transformer_common_1.DEFAULT_SCALARS).includes(typeName);
        };
        this.type = field.type;
        this.name = field.name.value;
        this.loc = field.loc;
        this.directives = (field.directives || []).map(d => new DirectiveWrapper(d));
    }
}
exports.GenericFieldWrapper = GenericFieldWrapper;
class InputFieldWraper extends GenericFieldWrapper {
    constructor(field) {
        super(field);
        this.field = field;
        this.serialize = () => {
            var _a;
            return {
                ...this.field,
                kind: 'InputValueDefinition',
                name: { kind: 'Name', value: this.name },
                type: this.type,
                description: this.description,
                directives: (_a = this.directives) === null || _a === void 0 ? void 0 : _a.map(d => d.serialize()),
            };
        };
        this.type = field.type;
        this.name = field.name.value;
    }
}
exports.InputFieldWraper = InputFieldWraper;
InputFieldWraper.fromField = (name, field) => {
    return new InputFieldWraper({
        kind: 'InputValueDefinition',
        name: { kind: 'Name', value: name },
        type: field.type,
    });
};
InputFieldWraper.create = (name, type, isNullable = false, isList = false) => {
    const field = new InputFieldWraper({
        kind: 'InputValueDefinition',
        name: {
            kind: 'Name',
            value: name,
        },
        type: {
            kind: 'NamedType',
            name: {
                value: type,
                kind: 'Name',
            },
        },
    });
    if (!isNullable) {
        field.makeNonNullable();
    }
    if (isList) {
        field.wrapListType();
    }
    return field;
};
class FieldWrapper extends GenericFieldWrapper {
    constructor(field) {
        super(field);
        this.serialize = () => {
            var _a;
            return {
                kind: 'FieldDefinition',
                name: { kind: 'Name', value: this.name },
                type: this.type,
                arguments: this.argumenets,
                description: this.description,
                directives: (_a = this.directives) === null || _a === void 0 ? void 0 : _a.map(d => d.serialize()),
            };
        };
        this.argumenets = [...(field.arguments || [])];
        this.description = field.description;
        this.loc = field.loc;
    }
}
exports.FieldWrapper = FieldWrapper;
FieldWrapper.create = (name, type, isNullable = false, isList = false) => {
    const field = new FieldWrapper({
        kind: 'FieldDefinition',
        name: {
            kind: 'Name',
            value: name,
        },
        type: {
            kind: 'NamedType',
            name: {
                value: type,
                kind: 'Name',
            },
        },
    });
    if (!isNullable) {
        field.makeNonNullable();
    }
    if (isList) {
        field.wrapListType();
    }
    return field;
};
class ObjectDefinationWrapper {
    constructor(node) {
        this.node = node;
        this.serialize = () => {
            var _a;
            return {
                ...this.node,
                name: {
                    kind: 'Name',
                    value: this.name,
                },
                fields: this.fields.map(f => f.serialize()),
                directives: (_a = this.directives) === null || _a === void 0 ? void 0 : _a.map(d => d.serialize()),
            };
        };
        this.hasField = (name) => {
            const field = this.fields.find(f => f.name === name);
            return field ? true : false;
        };
        this.getField = (name) => {
            const field = this.fields.find(f => f.name === name);
            if (!field) {
                throw new Error(`Field ${name} missing in type ${this.name}`);
            }
            return field;
        };
        this.addField = (field) => {
            if (this.hasField(field.name)) {
                throw new Error(`type ${this.name} has already a field with name ${field.name}`);
            }
            this.fields.push(field);
        };
        this.removeField = (field) => {
            if (this.hasField(field.name)) {
                throw new Error(`type ${this.name} does not have the field with name ${field.name}`);
            }
            const index = this.fields.indexOf(field);
            this.fields.splice(index, 1);
        };
        this.directives = (node.directives || []).map(d => new DirectiveWrapper(d));
        this.fields = (node.fields || []).map(f => new FieldWrapper(f));
        this.name = node.name.value;
    }
}
exports.ObjectDefinationWrapper = ObjectDefinationWrapper;
ObjectDefinationWrapper.create = (name, fields = [], directives = []) => {
    return new ObjectDefinationWrapper({
        kind: 'ObjectTypeDefinition',
        name: {
            kind: 'Name',
            value: name,
        },
        fields: fields,
        directives: directives,
    });
};
class InputObjectDefinitionWrapper {
    constructor(node) {
        this.node = node;
        this.serialize = () => {
            var _a;
            return {
                ...this.node,
                fields: this.fields.map(f => f.serialize()),
                directives: (_a = this.directives) === null || _a === void 0 ? void 0 : _a.map(d => d.serialize()),
            };
        };
        this.hasField = (name) => {
            const field = this.fields.find(f => f.name === name);
            return field ? true : false;
        };
        this.getField = (name) => {
            const field = this.fields.find(f => f.name === name);
            if (!field) {
                throw new Error(`Field ${name} missing in type ${this.name}`);
            }
            return field;
        };
        this.addField = (field) => {
            if (this.hasField(field.name)) {
                throw new Error(`type ${this.name} has already a field with name ${field.name}`);
            }
            this.fields.push(field);
        };
        this.removeField = (field) => {
            if (this.hasField(field.name)) {
                throw new Error(`type ${this.name} does not have the field with name ${field.name}`);
            }
            const index = this.fields.indexOf(field);
            this.fields.splice(index, 1);
        };
        this.directives = (node.directives || []).map(d => new DirectiveWrapper(d));
        this.fields = (node.fields || []).map(f => new InputFieldWraper(f));
        this.name = node.name.value;
    }
}
exports.InputObjectDefinitionWrapper = InputObjectDefinitionWrapper;
InputObjectDefinitionWrapper.create = (name, fields = [], directives = []) => {
    const wrappedObj = new InputObjectDefinitionWrapper({
        kind: 'InputObjectTypeDefinition',
        name: {
            kind: 'Name',
            value: name,
        },
        fields: [],
        directives: directives,
    });
    for (let field of fields) {
        const fieldWrapper = new InputFieldWraper(field);
        wrappedObj.addField(fieldWrapper);
    }
    return wrappedObj;
};
InputObjectDefinitionWrapper.fromObject = (name, def) => {
    const inputObj = {
        kind: 'InputObjectTypeDefinition',
        name: { kind: 'Name', value: name },
        fields: [],
        directives: [],
    };
    const wrappedInput = new InputObjectDefinitionWrapper(inputObj);
    for (let f of def.fields || []) {
        const wrappedField = new InputFieldWraper({
            kind: 'InputValueDefinition',
            name: f.name,
            type: f.type,
            directives: [],
        });
        wrappedInput.fields.push(wrappedField);
    }
    return wrappedInput;
};
class EnumWrapper {
    constructor(node) {
        var _a;
        this.node = node;
        this.addValue = (value) => {
            this.values.push(value);
        };
        this.serialize = () => {
            return {
                ...this.node,
                name: {
                    kind: 'Name',
                    value: this.name,
                },
                directives: this.directives.map(d => d.serialize()),
                values: this.values.map(value => ({
                    kind: 'EnumValueDefinition',
                    name: {
                        kind: 'Name',
                        value: value,
                    },
                })),
            };
        };
        this.name = node.name.value;
        this.values = ((_a = node.values) === null || _a === void 0 ? void 0 : _a.map(v => v.name.value)) || [];
        this.directives = (node.directives || []).map(d => new DirectiveWrapper(d));
    }
}
exports.EnumWrapper = EnumWrapper;
EnumWrapper.create = (name, values = []) => {
    const wrappedEnum = new EnumWrapper({
        kind: 'EnumTypeDefinition',
        name: {
            kind: 'Name',
            value: name,
        },
        values: [],
    });
    values.forEach(val => {
        wrappedEnum.addValue(val);
    });
    return wrappedEnum;
};
//# sourceMappingURL=object-definition-wrapper.js.map