"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchableModelTransformer = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const core_1 = require("@aws-cdk/core");
const graphql_mapping_template_1 = require("graphql-mapping-template");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const create_cfnParameters_1 = require("./cdk/create-cfnParameters");
const generate_resolver_vtl_1 = require("./generate-resolver-vtl");
const definitions_1 = require("./definitions");
const assert_1 = __importDefault(require("assert"));
const create_layer_cfnMapping_1 = require("./cdk/create-layer-cfnMapping");
const create_es_domain_1 = require("./cdk/create-es-domain");
const create_es_datasource_1 = require("./cdk/create-es-datasource");
const create_streaming_lambda_1 = require("./cdk/create-streaming-lambda");
const create_cfnOutput_1 = require("./cdk/create-cfnOutput");
const nonKeywordTypes = ['Int', 'Float', 'Boolean', 'AWSTimestamp', 'AWSDate', 'AWSDateTime'];
const STACK_NAME = 'SearchableStack';
class SearchableModelTransformer extends graphql_transformer_core_1.TransformerPluginBase {
    constructor() {
        super('amplify-searchable-transformer', `
        directive @searchable(queries: SearchableQueryMap) on OBJECT
        input SearchableQueryMap {
          search: String
        }
      `);
        this.generateResolvers = (context) => {
            const { Env } = graphql_transformer_common_1.ResourceConstants.PARAMETERS;
            const { HasEnvironmentParameter } = graphql_transformer_common_1.ResourceConstants.CONDITIONS;
            const stack = context.stackManager.createStack(STACK_NAME);
            create_layer_cfnMapping_1.setMappings(stack);
            const envParam = context.stackManager.getParameter(Env);
            new core_1.CfnCondition(stack, HasEnvironmentParameter, {
                expression: core_1.Fn.conditionNot(core_1.Fn.conditionEquals(envParam, graphql_transformer_common_1.ResourceConstants.NONE)),
            });
            const isProjectUsingDataStore = false;
            stack.templateOptions.description = 'An auto-generated nested stack for searchable.';
            stack.templateOptions.templateFormatVersion = '2010-09-09';
            const parameterMap = create_cfnParameters_1.createParametersStack(stack);
            const domain = create_es_domain_1.createEsDomain(stack, parameterMap, context.api.apiId);
            const elasticsearchRole = create_es_domain_1.createEsDomainRole(stack, parameterMap, context.api.apiId, envParam);
            domain.grantReadWrite(elasticsearchRole);
            const datasource = create_es_datasource_1.createEsDataSource(stack, context.api, domain.domainEndpoint, elasticsearchRole, stack.parseArn(domain.domainArn).region);
            const lambdaRole = create_streaming_lambda_1.createLambdaRole(stack, parameterMap);
            domain.grantWrite(lambdaRole);
            const lambda = create_streaming_lambda_1.createLambda(stack, context.api, parameterMap, lambdaRole, domain.domainEndpoint, isProjectUsingDataStore, stack.parseArn(domain.domainArn).region);
            for (const def of this.searchableObjectTypeDefinitions) {
                const type = def.node.name.value;
                const typeName = context.output.getQueryTypeName();
                const table = getTable(context, def.node);
                const ddbTable = table;
                assert_1.default(ddbTable);
                ddbTable.grantStreamRead(lambdaRole);
                create_streaming_lambda_1.createEventSourceMapping(stack, type, lambda, ddbTable.tableStreamArn);
                const { attributeName } = table.keySchema.find((att) => att.keyType === 'HASH');
                assert_1.default(typeName);
                const resolver = context.resolvers.generateQueryResolver(typeName, def.fieldName, datasource, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(generate_resolver_vtl_1.requestTemplate(attributeName, getNonKeywordFields(def.node), false, type), `${typeName}.${def.fieldName}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(generate_resolver_vtl_1.responseTemplate(false), `${typeName}.${def.fieldName}.res.vtl`));
                resolver.mapToStack(stack);
                context.resolvers.addResolver(type, def.fieldName, resolver);
            }
            create_cfnOutput_1.createStackOutputs(stack, domain.domainEndpoint, context.api.apiId, domain.domainArn);
        };
        this.object = (definition, directive, ctx) => {
            var _a;
            const modelDirective = (_a = definition === null || definition === void 0 ? void 0 : definition.directives) === null || _a === void 0 ? void 0 : _a.find(dir => dir.name.value === 'model');
            if (!modelDirective) {
                throw new graphql_transformer_core_1.InvalidDirectiveError('Types annotated with @searchable must also be annotated with @model.');
            }
            const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
            const directiveArguments = directiveWrapped.getArguments({});
            let shouldMakeSearch = true;
            let searchFieldNameOverride = undefined;
            if (directiveArguments.queries) {
                if (!directiveArguments.queries.search) {
                    shouldMakeSearch = false;
                }
                else {
                    searchFieldNameOverride = directiveArguments.queries.search;
                }
            }
            const fieldName = searchFieldNameOverride ? searchFieldNameOverride : graphql_transformer_common_1.graphqlName(`search${graphql_transformer_common_1.plurality(graphql_transformer_common_1.toUpper(definition.name.value))}`);
            this.searchableObjectTypeDefinitions.push({
                node: definition,
                fieldName,
            });
            if (shouldMakeSearch) {
                this.generateSearchableInputs(ctx, definition);
                this.generateSearchableXConnectionType(ctx, definition);
                const queryField = graphql_transformer_common_1.makeField(fieldName, [
                    graphql_transformer_common_1.makeInputValueDefinition('filter', graphql_transformer_common_1.makeNamedType(`Searchable${definition.name.value}FilterInput`)),
                    graphql_transformer_common_1.makeInputValueDefinition('sort', graphql_transformer_common_1.makeNamedType(`Searchable${definition.name.value}SortInput`)),
                    graphql_transformer_common_1.makeInputValueDefinition('limit', graphql_transformer_common_1.makeNamedType('Int')),
                    graphql_transformer_common_1.makeInputValueDefinition('nextToken', graphql_transformer_common_1.makeNamedType('String')),
                    graphql_transformer_common_1.makeInputValueDefinition('from', graphql_transformer_common_1.makeNamedType('Int')),
                ], graphql_transformer_common_1.makeNamedType(`Searchable${definition.name.value}Connection`));
                ctx.output.addQueryFields([queryField]);
            }
        };
        this.searchableObjectTypeDefinitions = [];
    }
    generateSearchableXConnectionType(ctx, definition) {
        const searchableXConnectionName = `Searchable${definition.name.value}Connection`;
        if (ctx.output.hasType(searchableXConnectionName)) {
            return;
        }
        const connectionType = graphql_transformer_common_1.blankObject(searchableXConnectionName);
        ctx.output.addObject(connectionType);
        let connectionTypeExtension = graphql_transformer_common_1.blankObjectExtension(searchableXConnectionName);
        connectionTypeExtension = graphql_transformer_common_1.extensionWithFields(connectionTypeExtension, [
            graphql_transformer_common_1.makeField('items', [], graphql_transformer_common_1.makeListType(graphql_transformer_common_1.makeNamedType(definition.name.value))),
        ]);
        connectionTypeExtension = graphql_transformer_common_1.extensionWithFields(connectionTypeExtension, [
            graphql_transformer_common_1.makeField('nextToken', [], graphql_transformer_common_1.makeNamedType('String')),
            graphql_transformer_common_1.makeField('total', [], graphql_transformer_common_1.makeNamedType('Int')),
        ]);
        ctx.output.addObjectExtension(connectionTypeExtension);
    }
    generateSearchableInputs(ctx, definition) {
        const inputs = Object.keys(graphql_transformer_common_1.STANDARD_SCALARS);
        inputs
            .filter(input => !ctx.output.hasType(`Searchable${input}FilterInput`))
            .map(definitions_1.makeSearchableScalarInputObject)
            .forEach((node) => ctx.output.addInput(node));
        const searchableXQueryFilterInput = definitions_1.makeSearchableXFilterInputObject(definition);
        if (!ctx.output.hasType(searchableXQueryFilterInput.name.value)) {
            ctx.output.addInput(searchableXQueryFilterInput);
        }
        if (!ctx.output.hasType('SearchableSortDirection')) {
            const searchableSortDirection = definitions_1.makeSearchableSortDirectionEnumObject();
            ctx.output.addEnum(searchableSortDirection);
        }
        if (!ctx.output.hasType(`Searchable${definition.name.value}SortableFields`)) {
            const searchableXSortableFieldsDirection = definitions_1.makeSearchableXSortableFieldsEnumObject(definition);
            ctx.output.addEnum(searchableXSortableFieldsDirection);
        }
        if (!ctx.output.hasType(`Searchable${definition.name.value}SortInput`)) {
            const searchableXSortableInputDirection = definitions_1.makeSearchableXSortInputObject(definition);
            ctx.output.addInput(searchableXSortableInputDirection);
        }
    }
}
exports.SearchableModelTransformer = SearchableModelTransformer;
function getTable(context, definition) {
    const ddbDataSource = context.dataSources.get(definition);
    const tableName = graphql_transformer_common_1.ModelResourceIDs.ModelTableResourceID(definition.name.value);
    const table = ddbDataSource.ds.stack.node.findChild(tableName);
    return table;
}
function getNonKeywordFields(def) {
    var _a;
    const nonKeywordTypeSet = new Set(nonKeywordTypes);
    return ((_a = def.fields) === null || _a === void 0 ? void 0 : _a.filter(field => nonKeywordTypeSet.has(graphql_transformer_common_1.getBaseType(field.type))).map(field => graphql_mapping_template_1.str(field.name.value))) || [];
}
//# sourceMappingURL=graphql-searchable-transformer.js.map