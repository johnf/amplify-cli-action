"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphQLApi = exports.IamResource = void 0;
const aws_appsync_1 = require("@aws-cdk/aws-appsync");
const aws_iam_1 = require("@aws-cdk/aws-iam");
const aws_lambda_1 = require("@aws-cdk/aws-lambda");
const core_1 = require("@aws-cdk/core");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const appsync_function_1 = require("./appsync-function");
const elasticsearch_datasource_1 = require("./cdk-compat/elasticsearch-datasource");
const schema_asset_1 = require("./cdk-compat/schema-asset");
const template_asset_1 = require("./cdk-compat/template-asset");
class IamResource {
    constructor(arns) {
        this.arns = arns;
    }
    static custom(...arns) {
        if (arns.length === 0) {
            throw new Error('At least 1 custom ARN must be provided.');
        }
        return new IamResource(arns);
    }
    static ofType(type, ...fields) {
        const arns = fields.length ? fields.map(field => `types/${type}/fields/${field}`) : [`types/${type}/*`];
        return new IamResource(arns);
    }
    static all() {
        return new IamResource(['*']);
    }
    resourceArns(api) {
        return this.arns.map(arn => core_1.Stack.of(api).formatArn({
            service: 'appsync',
            resource: `apis/${api.apiId}`,
            sep: '/',
            resourceName: `${arn}`,
        }));
    }
}
exports.IamResource = IamResource;
class GraphQLApi extends aws_appsync_1.GraphqlApiBase {
    constructor(scope, id, props) {
        var _a, _b;
        super(scope, id);
        this.dataSources = new Map();
        this.getDataSource = (name) => {
            if (this.hasDataSource(name)) {
                return this.dataSources.get(name);
            }
        };
        this.authorizationConfig = {
            defaultAuthorization: { authorizationType: aws_appsync_1.AuthorizationType.API_KEY },
            additionalAuthorizationModes: [],
            ...props.authorizationConfig,
        };
        const defaultMode = this.authorizationConfig.defaultAuthorization;
        const additionalModes = this.authorizationConfig.additionalAuthorizationModes;
        const modes = [defaultMode, ...additionalModes];
        this.modes = modes.map(mode => mode.authorizationType);
        this.validateAuthorizationProps(modes);
        this.api = new aws_appsync_1.CfnGraphQLApi(this, 'Resource', {
            name: props.name,
            authenticationType: defaultMode.authorizationType,
            logConfig: this.setupLogConfig(props.logConfig),
            openIdConnectConfig: this.setupOpenIdConnectConfig(defaultMode.openIdConnectConfig),
            userPoolConfig: this.setupUserPoolConfig(defaultMode.userPoolConfig),
            additionalAuthenticationProviders: this.setupAdditionalAuthorizationModes(additionalModes),
            xrayEnabled: props.xrayEnabled,
        });
        this.apiId = this.api.attrApiId;
        this.arn = this.api.attrArn;
        this.graphqlUrl = this.api.attrGraphQlUrl;
        this.name = this.api.name;
        this.schema = (_a = props.schema) !== null && _a !== void 0 ? _a : new schema_asset_1.TransformerSchema();
        this.schemaResource = this.schema.bind(this);
        if (props.createApiKey && modes.some(mode => mode.authorizationType === aws_appsync_1.AuthorizationType.API_KEY)) {
            const config = (_b = modes.find((mode) => {
                return mode.authorizationType === aws_appsync_1.AuthorizationType.API_KEY && mode.apiKeyConfig;
            })) === null || _b === void 0 ? void 0 : _b.apiKeyConfig;
            this.apiKeyResource = this.createAPIKey(config);
            this.apiKeyResource.addDependsOn(this.schemaResource);
            this.apiKey = this.apiKeyResource.attrApiKey;
        }
    }
    addElasticSearchDataSource(name, awsRegion, endpoint, options, stack) {
        if (this.dataSources.has(name)) {
            throw new Error(`DataSource ${name} already exists in the API`);
        }
        const data = this.doAddElasticSearchDataSource(name, endpoint, awsRegion, options, stack);
        this.dataSources.set((options === null || options === void 0 ? void 0 : options.name) || name, data);
        return data;
    }
    addHttpDataSource(name, endpoint, options, stack) {
        if (this.dataSources.has(name)) {
            throw new Error(`DataSource ${name} already exists in the API`);
        }
        const dataSource = this.doAddHttpDataSource(name, endpoint, options, stack);
        this.dataSources.set(name, dataSource);
        return dataSource;
    }
    addDynamoDbDataSource(name, table, options, stack) {
        if (this.dataSources.has(name)) {
            throw new Error(`DataSource ${name} already exists in the API`);
        }
        const dataSource = this.doAddDynamoDbDataSource(name, table, options, stack);
        this.dataSources.set((options === null || options === void 0 ? void 0 : options.name) || name, dataSource);
        return dataSource;
    }
    addNoneDataSource(name, options, stack) {
        if (this.dataSources.has(name)) {
            throw new Error(`DataSource ${name} already exists in the API`);
        }
        const dataSource = this.doAddNoneDataSource(name, options, stack);
        this.dataSources.set(name, dataSource);
        return dataSource;
    }
    addLambdaDataSource(name, lambdaFunction, options, stack) {
        if (!core_1.Token.isUnresolved(name) && this.dataSources.has(name)) {
            throw new Error(`DataSource ${name} already exists in the API`);
        }
        const dataSource = this.doAddLambdaDataSource(name, lambdaFunction, options, stack);
        this.dataSources.set(name, dataSource);
        return dataSource;
    }
    addAppSyncFunction(name, requestMappingTemplate, responseMappingTemplate, dataSourceName, stack) {
        if (dataSourceName && !core_1.Token.isUnresolved(dataSourceName) && !this.dataSources.has(dataSourceName)) {
            throw new Error(`DataSource ${dataSourceName} is missing in the API`);
        }
        const dataSource = this.dataSources.get(dataSourceName);
        const fn = new appsync_function_1.AppSyncFunctionConfiguration(stack || this, name, {
            api: this,
            dataSource: dataSource || dataSourceName,
            requestMappingTemplate,
            responseMappingTemplate,
        });
        return fn;
    }
    addLambdaFunction(functionName, functionKey, handlerName, filePath, runtime, layers, role, environment, stack) {
        const dummycode = `if __name__ == "__main__":`;
        const fn = new aws_lambda_1.Function(stack || this, functionName, {
            code: aws_lambda_1.Code.fromInline(dummycode),
            handler: handlerName,
            runtime,
            role,
            layers,
            environment,
        });
        fn.addLayers();
        const functionCode = new template_asset_1.S3MappingFunctionCode(functionKey, filePath).bind(fn);
        fn.node.defaultChild.code = {
            s3Key: functionCode.s3ObjectKey,
            s3Bucket: functionCode.s3BucketName,
        };
        return fn;
    }
    grant(grantee, resources, ...actions) {
        return aws_iam_1.Grant.addToPrincipal({
            grantee,
            actions,
            resourceArns: resources.resourceArns(this),
            scope: this,
        });
    }
    grantQuery(grantee, ...fields) {
        return this.grant(grantee, IamResource.ofType('Query', ...fields), 'appsync:GraphQL');
    }
    grantMutation(grantee, ...fields) {
        return this.grant(grantee, IamResource.ofType('Mutation', ...fields), 'appsync:GraphQL');
    }
    grantSubscription(grantee, ...fields) {
        return this.grant(grantee, IamResource.ofType('Subscription', ...fields), 'appsync:GraphQL');
    }
    createAPIKey(config) {
        var _a, _b;
        if (((_a = config === null || config === void 0 ? void 0 : config.expires) === null || _a === void 0 ? void 0 : _a.isBefore(core_1.Duration.days(1))) || ((_b = config === null || config === void 0 ? void 0 : config.expires) === null || _b === void 0 ? void 0 : _b.isAfter(core_1.Duration.days(365)))) {
            throw Error('API key expiration must be between 1 and 365 days.');
        }
        const expires = (config === null || config === void 0 ? void 0 : config.expires) ? config === null || config === void 0 ? void 0 : config.expires.toEpoch() : undefined;
        return new aws_appsync_1.CfnApiKey(this, `${(config === null || config === void 0 ? void 0 : config.name) || 'Default'}ApiKey`, {
            expires,
            description: (config === null || config === void 0 ? void 0 : config.description) || undefined,
            apiId: this.apiId,
        });
    }
    addToSchema(content) {
        this.schema.addToSchema(content, '\n');
    }
    getDefaultAuthorization() {
        var _a;
        return (_a = this.authorizationConfig) === null || _a === void 0 ? void 0 : _a.defaultAuthorization;
    }
    addResolver(typeName, fieldName, requestMappingTemplate, responseMappingTemplate, dataSourceName, pipelineConfig, stack) {
        if (dataSourceName && !core_1.Token.isUnresolved(dataSourceName) && !this.dataSources.has(dataSourceName)) {
            throw new Error(`DataSource ${dataSourceName} is missing in the API`);
        }
        const requestTemplateLocation = requestMappingTemplate.bind(this);
        const responseTemplateLocation = responseMappingTemplate.bind(this);
        const resolverName = graphql_transformer_common_1.toCamelCase([typeName, fieldName, 'Resolver']);
        if (dataSourceName) {
            const dataSource = this.dataSources.get(dataSourceName);
            const resolver = new aws_appsync_1.CfnResolver(stack || this, resolverName, {
                apiId: this.apiId,
                fieldName: fieldName,
                typeName: typeName,
                kind: 'UNIT',
                dataSourceName: (dataSource === null || dataSource === void 0 ? void 0 : dataSource.ds.attrName) || dataSourceName,
                ...(requestMappingTemplate instanceof template_asset_1.InlineTemplate
                    ? { requestMappingTemplate: requestTemplateLocation }
                    : { requestMappingTemplateS3Location: requestTemplateLocation }),
                ...(responseMappingTemplate instanceof template_asset_1.InlineTemplate
                    ? { responseMappingTemplate: responseTemplateLocation }
                    : { responseMappingTemplateS3Location: responseTemplateLocation }),
            });
            this.addSchemaDependency(resolver);
            return resolver;
        }
        else if (pipelineConfig) {
            const resolver = new aws_appsync_1.CfnResolver(stack || this, resolverName, {
                apiId: this.apiId,
                fieldName: fieldName,
                typeName: typeName,
                kind: 'PIPELINE',
                ...(requestMappingTemplate instanceof template_asset_1.InlineTemplate
                    ? { requestMappingTemplate: requestTemplateLocation }
                    : { requestMappingTemplateS3Location: requestTemplateLocation }),
                ...(responseMappingTemplate instanceof template_asset_1.InlineTemplate
                    ? { responseMappingTemplate: responseTemplateLocation }
                    : { responseMappingTemplateS3Location: responseTemplateLocation }),
                pipelineConfig: {
                    functions: pipelineConfig,
                },
            });
            this.addSchemaDependency(resolver);
            return resolver;
        }
        else {
            throw new Error('Resolver needs either dataSourceName or pipelineConfig to be passed');
        }
    }
    hasDataSource(name) {
        return this.dataSources.has(name);
    }
    doAddNoneDataSource(id, options, stack) {
        return new aws_appsync_1.NoneDataSource(stack !== null && stack !== void 0 ? stack : this, id, {
            api: this,
            name: options === null || options === void 0 ? void 0 : options.name,
            description: options === null || options === void 0 ? void 0 : options.description,
        });
    }
    doAddDynamoDbDataSource(id, table, options, stack) {
        return new aws_appsync_1.DynamoDbDataSource(stack !== null && stack !== void 0 ? stack : this, id, {
            api: this,
            table,
            name: options === null || options === void 0 ? void 0 : options.name,
            description: options === null || options === void 0 ? void 0 : options.description,
        });
    }
    doAddHttpDataSource(id, endpoint, options, stack) {
        return new aws_appsync_1.HttpDataSource(stack !== null && stack !== void 0 ? stack : this, id, {
            api: this,
            endpoint,
            name: options === null || options === void 0 ? void 0 : options.name,
            description: options === null || options === void 0 ? void 0 : options.description,
            authorizationConfig: options === null || options === void 0 ? void 0 : options.authorizationConfig,
        });
    }
    doAddElasticSearchDataSource(id, endpoint, region, options, stack) {
        return new elasticsearch_datasource_1.ElasticsearchDataSource(stack !== null && stack !== void 0 ? stack : this, id, {
            api: this,
            name: options === null || options === void 0 ? void 0 : options.name,
            endpoint,
            region,
            serviceRole: options === null || options === void 0 ? void 0 : options.serviceRole,
        });
    }
    doAddLambdaDataSource(id, lambdaFunction, options, stack) {
        return new aws_appsync_1.LambdaDataSource(stack || this, id, {
            api: this,
            lambdaFunction,
            name: options === null || options === void 0 ? void 0 : options.name,
            description: options === null || options === void 0 ? void 0 : options.description,
        });
    }
    validateAuthorizationProps(modes) {
        modes.forEach(mode => {
            if (mode.authorizationType === aws_appsync_1.AuthorizationType.OIDC && !mode.openIdConnectConfig) {
                throw new Error('Missing default OIDC Configuration');
            }
            if (mode.authorizationType === aws_appsync_1.AuthorizationType.USER_POOL && !mode.userPoolConfig) {
                throw new Error('Missing default OIDC Configuration');
            }
        });
        if (modes.filter(mode => mode.authorizationType === aws_appsync_1.AuthorizationType.API_KEY).length > 1) {
            throw new Error("You can't duplicate API_KEY configuration. See https://docs.aws.amazon.com/appsync/latest/devguide/security.html");
        }
        if (modes.filter(mode => mode.authorizationType === aws_appsync_1.AuthorizationType.IAM).length > 1) {
            throw new Error("You can't duplicate IAM configuration. See https://docs.aws.amazon.com/appsync/latest/devguide/security.html");
        }
    }
    addSchemaDependency(construct) {
        construct.addDependsOn(this.schemaResource);
        return true;
    }
    setupLogConfig(config) {
        if (!config)
            return undefined;
        const role = new aws_iam_1.Role(this, 'ApiLogsRole', {
            assumedBy: new aws_iam_1.ServicePrincipal('appsync.amazonaws.com'),
            managedPolicies: [aws_iam_1.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSAppSyncPushToCloudWatchLogs')],
        });
        return {
            cloudWatchLogsRoleArn: role.roleArn,
            excludeVerboseContent: config.excludeVerboseContent,
            fieldLogLevel: config.fieldLogLevel,
        };
    }
    setupOpenIdConnectConfig(config) {
        if (!config)
            return undefined;
        return {
            authTtl: config.tokenExpiryFromAuth,
            clientId: config.clientId,
            iatTtl: config.tokenExpiryFromIssue,
            issuer: config.oidcProvider,
        };
    }
    setupUserPoolConfig(config) {
        if (!config)
            return undefined;
        return {
            userPoolId: config.userPool.userPoolId,
            awsRegion: config.userPool.stack.region,
            appIdClientRegex: config.appIdClientRegex,
            defaultAction: config.defaultAction || aws_appsync_1.UserPoolDefaultAction.ALLOW,
        };
    }
    setupAdditionalAuthorizationModes(modes) {
        if (!modes || modes.length === 0)
            return undefined;
        return modes.reduce((acc, mode) => [
            ...acc,
            {
                authenticationType: mode.authorizationType,
                userPoolConfig: this.setupUserPoolConfig(mode.userPoolConfig),
                openIdConnectConfig: this.setupOpenIdConnectConfig(mode.openIdConnectConfig),
            },
        ], []);
    }
}
exports.GraphQLApi = GraphQLApi;
//# sourceMappingURL=graphql-api.js.map