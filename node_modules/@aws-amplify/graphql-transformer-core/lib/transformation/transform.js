"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphQLTransform = void 0;
const aws_appsync_1 = require("@aws-cdk/aws-appsync");
const core_1 = require("@aws-cdk/core");
const assert_1 = __importDefault(require("assert"));
const graphql_1 = require("graphql");
const errors_1 = require("../errors");
const graphql_api_1 = require("../graphql-api");
const transformer_context_1 = require("../transformer-context");
const authType_1 = require("../utils/authType");
const utils_1 = require("./utils");
const validation_1 = require("./validation");
function isFunction(obj) {
    return obj && typeof obj === 'function';
}
class GraphQLTransform {
    constructor(options) {
        this.options = options;
        this.seenTransformations = {};
        if (!options.transformers || options.transformers.length === 0) {
            throw new Error('Must provide at least one transformer.');
        }
        const sortedTransformers = utils_1.sortTransformerPlugins(options.transformers);
        this.transformers = sortedTransformers;
        this.authConfig = options.authConfig || {
            defaultAuthentication: {
                authenticationType: 'API_KEY',
                apiKeyConfig: {
                    apiKeyExpirationDays: 7,
                    description: 'Default API Key',
                },
            },
            additionalAuthenticationProviders: [],
        };
        this.buildParameters = options.buildParameters || {};
        this.stackMappingOverrides = options.stackMapping || {};
    }
    transform(schema) {
        this.seenTransformations = {};
        const parsedDocument = graphql_1.parse(schema);
        this.app = new core_1.App();
        const context = new transformer_context_1.TransformerContext(this.app, parsedDocument, this.stackMappingOverrides, this.options.featuerFlags);
        const validDirectiveNameMap = this.transformers.reduce((acc, t) => ({ ...acc, [t.directive.name.value]: true }), {
            aws_subscribe: true,
            aws_auth: true,
            aws_api_key: true,
            aws_iam: true,
            aws_oidc: true,
            aws_cognito_user_pools: true,
            deprecated: true,
        });
        let allModelDefinitions = [...context.inputDocument.definitions];
        for (const transformer of this.transformers) {
            allModelDefinitions = allModelDefinitions.concat(...transformer.typeDefinitions, transformer.directive);
        }
        const errors = validation_1.validateModelSchema({
            kind: graphql_1.Kind.DOCUMENT,
            definitions: allModelDefinitions,
        });
        if (errors && errors.length) {
            throw new errors_1.SchemaValidationError(errors);
        }
        for (const transformer of this.transformers) {
            if (isFunction(transformer.before)) {
                transformer.before(context);
            }
        }
        for (const transformer of this.transformers) {
            for (const def of context.inputDocument.definitions) {
                switch (def.kind) {
                    case 'ObjectTypeDefinition':
                        this.transformObject(transformer, def, validDirectiveNameMap, context);
                        break;
                    case 'InterfaceTypeDefinition':
                        this.transformInterface(transformer, def, validDirectiveNameMap, context);
                        break;
                    case 'ScalarTypeDefinition':
                        this.transformScalar(transformer, def, validDirectiveNameMap, context);
                        break;
                    case 'UnionTypeDefinition':
                        this.transformUnion(transformer, def, validDirectiveNameMap, context);
                        break;
                    case 'EnumTypeDefinition':
                        this.transformEnum(transformer, def, validDirectiveNameMap, context);
                        break;
                    case 'InputObjectTypeDefinition':
                        this.transformInputObject(transformer, def, validDirectiveNameMap, context);
                        break;
                    default:
                        continue;
                }
            }
        }
        for (const transformer of this.transformers) {
            if (isFunction(transformer.validate)) {
                transformer.validate(context);
            }
        }
        for (const transformer of this.transformers) {
            if (isFunction(transformer.prepare)) {
                transformer.prepare(context);
            }
        }
        for (const transformer of this.transformers) {
            if (isFunction(transformer.transformSchema)) {
                transformer.transformSchema(context);
            }
        }
        const stackManager = context.stackManager;
        const output = context.output;
        const api = this.generateGraphQlApi(stackManager, output);
        context.bind(api);
        for (const transformer of this.transformers) {
            if (isFunction(transformer.generateResolvers)) {
                transformer.generateResolvers(context);
            }
        }
        let reverseThroughTransformers = this.transformers.length - 1;
        while (reverseThroughTransformers >= 0) {
            const transformer = this.transformers[reverseThroughTransformers];
            if (isFunction(transformer.after)) {
                transformer.after(context);
            }
            reverseThroughTransformers -= 1;
        }
        this.collectResolvers(context, context.api);
        return this.synthesize(context);
    }
    generateGraphQlApi(stackManager, output) {
        var _a, _b;
        const rootStack = stackManager.rootStack;
        const authorizationConfig = authType_1.adoptAuthModes(stackManager, this.authConfig);
        const apiName = stackManager.addParameter('AppSyncApiName', { type: 'String' }).valueAsString;
        const envName = stackManager.getParameter('env');
        assert_1.default(envName);
        const api = new graphql_api_1.GraphQLApi(rootStack, 'GraphQLAPI', {
            name: `${apiName}-${envName.valueAsString}`,
            authorizationConfig,
        });
        const authModes = [authorizationConfig.defaultAuthorization, ...(authorizationConfig.additionalAuthorizationModes || [])].map(mode => mode === null || mode === void 0 ? void 0 : mode.authorizationType);
        if (authModes.includes(aws_appsync_1.AuthorizationType.API_KEY) &&
            !(this.buildParameters.CreateAPIKey && this.buildParameters.CreateAPIKey !== false)) {
            const apiKeyConfig = [
                authorizationConfig.defaultAuthorization,
                ...(authorizationConfig.additionalAuthorizationModes || []),
            ].find(auth => (auth === null || auth === void 0 ? void 0 : auth.authorizationType) == aws_appsync_1.AuthorizationType.API_KEY);
            const apiKeyDescription = (_a = apiKeyConfig.apiKeyConfig) === null || _a === void 0 ? void 0 : _a.description;
            const apiKeyExpirationDays = (_b = apiKeyConfig.apiKeyConfig) === null || _b === void 0 ? void 0 : _b.expires;
            const apiKey = api.createAPIKey({
                description: apiKeyDescription,
                expires: apiKeyExpirationDays,
            });
            new core_1.CfnOutput(rootStack, 'GraphQLAPIKeyOutput', {
                value: apiKey.attrApiKey,
                description: 'Your GraphQL API ID.',
                exportName: core_1.Fn.join(':', [core_1.Aws.STACK_NAME, 'GraphQLApiKey']),
            });
        }
        new core_1.CfnOutput(rootStack, 'GraphQLAPIIdOutput', {
            value: api.apiId,
            description: 'Your GraphQL API ID.',
            exportName: core_1.Fn.join(':', [core_1.Aws.STACK_NAME, 'GraphQLApiId']),
        });
        new core_1.CfnOutput(rootStack, 'GraphQLAPIEndpointOutput', {
            value: api.graphqlUrl,
            description: 'Your GraphQL API endpoint.',
            exportName: core_1.Fn.join(':', [core_1.Aws.STACK_NAME, 'GraphQLApiEndpoint']),
        });
        api.addToSchema(output.buildSchema());
        return api;
    }
    synthesize(context) {
        var _a;
        const stackManager = context.stackManager;
        (_a = this.app) === null || _a === void 0 ? void 0 : _a.synth({ force: true, skipValidation: true });
        const templates = stackManager.getCloudFormationTemplates();
        const rootStackTemplate = templates.get('transformer-root-stack');
        let childStacks = {};
        for (let [templateName, template] of templates.entries()) {
            if (templateName !== 'transformer-root-stack') {
                childStacks[templateName] = template;
            }
        }
        const fileAssets = stackManager.getMappingTemplates();
        const pipelineFunctions = {};
        const resolvers = {};
        const functions = {};
        for (let [templateName, template] of fileAssets) {
            if (templateName.startsWith('pipelineFunctions/')) {
                pipelineFunctions[templateName.replace('pipelineFunctions/', '')] = template;
            }
            else if (templateName.startsWith('resolvers/')) {
                resolvers[templateName.replace('resolvers/', '')] = template;
            }
            else if (templateName.startsWith('functions/')) {
                functions[templateName.replace('functions/', '')] = template;
            }
        }
        const schema = fileAssets.get('schema.graphql') || '';
        return {
            functions,
            pipelineFunctions,
            stackMapping: {},
            resolvers,
            schema,
            stacks: childStacks,
            rootStack: rootStackTemplate,
        };
    }
    collectResolvers(context, api) {
        const resolverEntries = context.resolvers.collectResolvers();
        for (let [, resolver] of resolverEntries) {
            resolver.synthesize(context, api);
        }
    }
    transformObject(transformer, def, validDirectiveNameMap, context) {
        var _a, _b;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if (utils_1.matchDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.object)) {
                    const transformKey = utils_1.makeSeenTransformationKey(dir, def, undefined, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.object(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'object()' method`);
                }
            }
            index++;
        }
        for (const field of (_b = def.fields) !== null && _b !== void 0 ? _b : []) {
            this.transformField(transformer, def, field, validDirectiveNameMap, context);
        }
    }
    transformField(transformer, parent, def, validDirectiveNameMap, context) {
        var _a, _b;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if (utils_1.matchFieldDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.field)) {
                    const transformKey = utils_1.makeSeenTransformationKey(dir, parent, def, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.field(parent, def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'field()' method`);
                }
            }
            index++;
        }
        for (const arg of (_b = def.arguments) !== null && _b !== void 0 ? _b : []) {
            this.transformArgument(transformer, parent, def, arg, validDirectiveNameMap, context);
        }
    }
    transformArgument(transformer, parent, field, arg, validDirectiveNameMap, context) {
        var _a;
        let index = 0;
        for (const dir of (_a = arg.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if (utils_1.matchArgumentDirective(transformer.directive, dir, arg)) {
                if (isFunction(transformer.argument)) {
                    const transformKey = utils_1.makeSeenTransformationKey(dir, parent, field, arg, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.argument(arg, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'argument()' method`);
                }
            }
            index++;
        }
    }
    transformInterface(transformer, def, validDirectiveNameMap, context) {
        var _a, _b;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if (utils_1.matchDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.interface)) {
                    const transformKey = utils_1.makeSeenTransformationKey(dir, def, undefined, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.interface(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'interface()' method`);
                }
            }
            index++;
        }
        for (const field of (_b = def.fields) !== null && _b !== void 0 ? _b : []) {
            this.transformField(transformer, def, field, validDirectiveNameMap, context);
        }
    }
    transformScalar(transformer, def, validDirectiveNameMap, context) {
        var _a;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if (utils_1.matchDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.scalar)) {
                    const transformKey = utils_1.makeSeenTransformationKey(dir, def, undefined, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.scalar(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'scalar()' method`);
                }
            }
            index++;
        }
    }
    transformUnion(transformer, def, validDirectiveNameMap, context) {
        var _a;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if (utils_1.matchDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.union)) {
                    const transformKey = utils_1.makeSeenTransformationKey(dir, def, undefined, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.union(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'union()' method`);
                }
            }
            index++;
        }
    }
    transformEnum(transformer, def, validDirectiveNameMap, context) {
        var _a, _b;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if (utils_1.matchDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.enum)) {
                    const transformKey = utils_1.makeSeenTransformationKey(dir, def, undefined, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.enum(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'enum()' method`);
                }
            }
            index++;
        }
        for (const value of (_b = def.values) !== null && _b !== void 0 ? _b : []) {
            this.transformEnumValue(transformer, def, value, validDirectiveNameMap, context);
        }
    }
    transformEnumValue(transformer, enm, def, validDirectiveNameMap, context) {
        var _a;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if (utils_1.matchEnumValueDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.enumValue)) {
                    const transformKey = utils_1.makeSeenTransformationKey(dir, enm, def, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.enumValue(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'enumValue()' method`);
                }
            }
            index++;
        }
    }
    transformInputObject(transformer, def, validDirectiveNameMap, context) {
        var _a, _b;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if (utils_1.matchDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.input)) {
                    const transformKey = utils_1.makeSeenTransformationKey(dir, def, undefined, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.input(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'input()' method`);
                }
            }
            index++;
        }
        for (const field of (_b = def.fields) !== null && _b !== void 0 ? _b : []) {
            this.transformInputField(transformer, def, field, validDirectiveNameMap, context);
        }
    }
    transformInputField(transformer, input, def, validDirectiveNameMap, context) {
        var _a;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if (utils_1.matchInputFieldDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.inputValue)) {
                    const transformKey = utils_1.makeSeenTransformationKey(dir, input, def, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.inputValue(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'inputValue()' method`);
                }
            }
            index++;
        }
    }
}
exports.GraphQLTransform = GraphQLTransform;
//# sourceMappingURL=transform.js.map