"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleAmplifyEvent = exports.executeAmplifyCommand = exports.isMockable = exports.getBuilder = exports.getInvoker = exports.initEnv = exports.getPermissionPolicies = exports.migrate = exports.console = exports.update = exports.add = exports.askExecRolePermissionsQuestions = exports.lambdasWithApiDependency = exports.updateDependentFunctionsCfn = exports.isMultiEnvLayer = exports.ServiceName = exports.hashLayerResource = exports.packageResource = exports.buildResource = exports.buildTypeKeyMap = exports.category = void 0;
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
var constants_2 = require("./constants");
Object.defineProperty(exports, "category", { enumerable: true, get: function () { return constants_2.category; } });
const amplify_cli_core_1 = require("amplify-cli-core");
const promise_sequential_1 = __importDefault(require("promise-sequential"));
const awscloudformation_1 = require("./provider-utils/awscloudformation");
const supported_services_1 = require("./provider-utils/supported-services");
const lodash_1 = __importDefault(require("lodash"));
var buildFunction_1 = require("./provider-utils/awscloudformation/utils/buildFunction");
Object.defineProperty(exports, "buildTypeKeyMap", { enumerable: true, get: function () { return buildFunction_1.buildTypeKeyMap; } });
var build_1 = require("./provider-utils/awscloudformation/utils/build");
Object.defineProperty(exports, "buildResource", { enumerable: true, get: function () { return build_1.buildResource; } });
var package_1 = require("./provider-utils/awscloudformation/utils/package");
Object.defineProperty(exports, "packageResource", { enumerable: true, get: function () { return package_1.packageResource; } });
var packageLayer_1 = require("./provider-utils/awscloudformation/utils/packageLayer");
Object.defineProperty(exports, "hashLayerResource", { enumerable: true, get: function () { return packageLayer_1.hashLayerResource; } });
var constants_3 = require("./provider-utils/awscloudformation/utils/constants");
Object.defineProperty(exports, "ServiceName", { enumerable: true, get: function () { return constants_3.ServiceName; } });
const layerParams_1 = require("./provider-utils/awscloudformation/utils/layerParams");
const buildFunction_2 = require("./provider-utils/awscloudformation/utils/buildFunction");
var layerParams_2 = require("./provider-utils/awscloudformation/utils/layerParams");
Object.defineProperty(exports, "isMultiEnvLayer", { enumerable: true, get: function () { return layerParams_2.isMultiEnvLayer; } });
var updateDependentFunctionCfn_1 = require("./provider-utils/awscloudformation/utils/updateDependentFunctionCfn");
Object.defineProperty(exports, "updateDependentFunctionsCfn", { enumerable: true, get: function () { return updateDependentFunctionCfn_1.updateDependentFunctionsCfn; } });
var getDependentFunction_1 = require("./provider-utils/awscloudformation/utils/getDependentFunction");
Object.defineProperty(exports, "lambdasWithApiDependency", { enumerable: true, get: function () { return getDependentFunction_1.lambdasWithApiDependency; } });
var execPermissionsWalkthrough_1 = require("./provider-utils/awscloudformation/service-walkthroughs/execPermissionsWalkthrough");
Object.defineProperty(exports, "askExecRolePermissionsQuestions", { enumerable: true, get: function () { return execPermissionsWalkthrough_1.askExecRolePermissionsQuestions; } });
async function add(context, providerName, service, parameters) {
    const options = {
        service,
        providerPlugin: providerName,
        build: true,
    };
    const providerController = require(`./provider-utils/${providerName}/index`);
    if (!providerController) {
        context.print.error('Provider not configured for this category');
        return;
    }
    return providerController.addResource(context, constants_1.category, service, options, parameters);
}
exports.add = add;
async function update(context, providerName, service, parameters, resourceToUpdate) {
    const providerController = require(`./provider-utils/${providerName}/index`);
    if (!providerController) {
        context.print.error('Provider not configured for this category');
        return;
    }
    return providerController.updateResource(context, constants_1.category, service, parameters, resourceToUpdate);
}
exports.update = update;
async function console(context) {
    context.print.info(`to be implemented: ${constants_1.category} console`);
}
exports.console = console;
async function migrate(context) {
    const { projectPath, amplifyMeta } = context.migrationInfo;
    const migrateResourcePromises = [];
    Object.keys(amplifyMeta).forEach(categoryName => {
        if (categoryName === constants_1.category) {
            Object.keys(amplifyMeta[constants_1.category]).forEach(resourceName => {
                try {
                    const providerController = require(`./provider-utils/${amplifyMeta[constants_1.category][resourceName].providerPlugin}/index`);
                    if (providerController) {
                        migrateResourcePromises.push(providerController.migrateResource(context, projectPath, amplifyMeta[constants_1.category][resourceName].service, resourceName));
                    }
                    else {
                        context.print.error(`Provider not configured for ${constants_1.category}: ${resourceName}`);
                    }
                }
                catch (e) {
                    context.print.warning(`Could not run migration for ${constants_1.category}: ${resourceName}`);
                    throw e;
                }
            });
        }
    });
    await Promise.all(migrateResourcePromises);
}
exports.migrate = migrate;
async function getPermissionPolicies(context, resourceOpsMapping) {
    const amplifyMeta = context.amplify.getProjectMeta();
    const permissionPolicies = [];
    const resourceAttributes = [];
    Object.keys(resourceOpsMapping).forEach(resourceName => {
        try {
            const providerName = amplifyMeta[constants_1.category][resourceName].providerPlugin;
            if (providerName) {
                const providerController = require(`./provider-utils/${providerName}/index`);
                const { policy, attributes } = providerController.getPermissionPolicies(context, amplifyMeta[constants_1.category][resourceName].service, resourceName, resourceOpsMapping[resourceName]);
                permissionPolicies.push(policy);
                resourceAttributes.push({ resourceName, attributes, category: constants_1.category });
            }
            else {
                context.print.error(`Provider not configured for ${constants_1.category}: ${resourceName}`);
            }
        }
        catch (e) {
            context.print.warning(`Could not get policies for ${constants_1.category}: ${resourceName}`);
            throw e;
        }
    });
    return { permissionPolicies, resourceAttributes };
}
exports.getPermissionPolicies = getPermissionPolicies;
async function initEnv(context) {
    var _a, _b;
    const { amplify } = context;
    const { envName } = amplify.getEnvInfo();
    const { allResources, resourcesToBeCreated, resourcesToBeDeleted, resourcesToBeUpdated } = await amplify.getResourceStatus(constants_1.category);
    const resourceCategoryFilter = resource => resource.category === constants_1.category;
    resourcesToBeDeleted.filter(resourceCategoryFilter).forEach(functionResource => {
        amplify.removeResourceParameters(context, constants_1.category, functionResource.resourceName);
    });
    const tasks = resourcesToBeCreated.concat(resourcesToBeUpdated).filter(resourceCategoryFilter);
    const functionTasks = tasks.map(functionResource => {
        const { resourceName, service } = functionResource;
        return async () => {
            const config = await awscloudformation_1.updateConfigOnEnvInit(context, resourceName, service);
            amplify.saveEnvResourceParameters(context, constants_1.category, resourceName, config);
        };
    });
    const sourceEnv = (_a = context.exeInfo) === null || _a === void 0 ? void 0 : _a.sourceEnvName;
    const isNewEnv = (_b = context.exeInfo) === null || _b === void 0 ? void 0 : _b.isNewEnv;
    const teamProviderInfo = amplify_cli_core_1.stateManager.getTeamProviderInfo();
    const currentAmplifyMeta = amplify_cli_core_1.stateManager.getCurrentMeta();
    const amplifyMeta = amplify_cli_core_1.stateManager.getMeta();
    const changedResources = [...resourcesToBeCreated, ...resourcesToBeDeleted, ...resourcesToBeUpdated];
    allResources
        .filter(resourceCategoryFilter)
        .filter(r => !changedResources.includes(r))
        .forEach(r => {
        const { resourceName, service } = r;
        const s3Bucket = lodash_1.default.get(currentAmplifyMeta, [constants_1.category, resourceName, 's3Bucket'], undefined);
        if (s3Bucket) {
            const tpiResourceParams = lodash_1.default.get(teamProviderInfo, [envName, 'categories', constants_1.category, resourceName], {});
            lodash_1.default.assign(tpiResourceParams, s3Bucket);
            lodash_1.default.set(teamProviderInfo, [envName, 'categories', constants_1.category, resourceName], tpiResourceParams);
            lodash_1.default.set(amplifyMeta, [constants_1.category, resourceName, 's3Bucket'], s3Bucket);
        }
        if (service === "LambdaLayer") {
            const lvmPath = [constants_1.category, resourceName, 'layerVersionMap'];
            const currentVersionMap = lodash_1.default.get(currentAmplifyMeta, lvmPath);
            if (layerParams_1.isMultiEnvLayer(context, resourceName)) {
                lodash_1.default.set(teamProviderInfo, [envName, 'nonCFNdata', ...lvmPath], currentVersionMap);
            }
            lodash_1.default.set(amplifyMeta, lvmPath, currentVersionMap);
        }
    });
    resourcesToBeCreated.forEach(resource => {
        const { resourceName, service } = resource;
        if (service === "Lambda") {
            if (sourceEnv && isNewEnv) {
                const groupName = lodash_1.default.get(teamProviderInfo, [sourceEnv, 'categories', constants_1.category, resourceName, 'GROUP']);
                if (groupName) {
                    lodash_1.default.set(teamProviderInfo, [envName, 'categories', constants_1.category, resourceName, 'GROUP'], groupName);
                }
            }
        }
    });
    amplify_cli_core_1.stateManager.setMeta(undefined, amplifyMeta);
    amplify_cli_core_1.stateManager.setTeamProviderInfo(undefined, teamProviderInfo);
    await promise_sequential_1.default(functionTasks);
}
exports.initEnv = initEnv;
async function getInvoker(context, { handler, resourceName, envVars }) {
    const resourcePath = path_1.default.join(amplify_cli_core_1.pathManager.getBackendDirPath(), constants_1.category, resourceName);
    const { pluginId, functionRuntime } = context.amplify.readBreadcrumbs(constants_1.category, resourceName);
    const runtimeManager = await context.amplify.loadRuntimePlugin(context, pluginId);
    return ({ event }) => runtimeManager.invoke({
        handler: handler,
        event: JSON.stringify(event),
        runtime: functionRuntime,
        srcRoot: resourcePath,
        envVars: envVars,
    });
}
exports.getInvoker = getInvoker;
function getBuilder(context, resourceName, buildType) {
    const lastBuildTimeStamp = lodash_1.default.get(amplify_cli_core_1.stateManager.getMeta(), [constants_1.category, resourceName, buildFunction_2.buildTypeKeyMap[buildType]]);
    return async () => {
        await buildFunction_2.buildFunction(context, { resourceName, buildType, lastBuildTimeStamp });
    };
}
exports.getBuilder = getBuilder;
function isMockable(context, resourceName) {
    const resourceValue = lodash_1.default.get(context.amplify.getProjectMeta(), [constants_1.category, resourceName]);
    if (!resourceValue) {
        return {
            isMockable: false,
            reason: `Could not find the specified ${constants_1.category}: ${resourceName}`,
        };
    }
    const { service, dependsOn } = resourceValue;
    const dependsOnLayers = Array.isArray(dependsOn)
        ? dependsOn
            .filter(dependency => dependency.category === 'function')
            .map(val => lodash_1.default.get(context.amplify.getProjectMeta(), [val.category, val.resourceName]))
            .filter(val => val.service === "LambdaLayer")
        : [];
    const hasLayer = service === "Lambda" && Array.isArray(dependsOnLayers) && dependsOnLayers.length !== 0;
    if (hasLayer) {
        return {
            isMockable: false,
            reason: 'Mocking a function with layers is not supported. ' +
                'To test in the cloud: run "amplify push" to deploy your function to the cloud ' +
                'and then run "amplify console function" to test your function in the Lambda console.',
        };
    }
    return supported_services_1.supportedServices[service].providerController.isMockable(service);
}
exports.isMockable = isMockable;
async function executeAmplifyCommand(context) {
    let commandPath = path_1.default.normalize(path_1.default.join(__dirname, 'commands'));
    if (context.input.command === 'help') {
        commandPath = path_1.default.join(commandPath, constants_1.category);
    }
    else {
        commandPath = path_1.default.join(commandPath, constants_1.category, context.input.command);
    }
    const commandModule = require(commandPath);
    await commandModule.run(context);
}
exports.executeAmplifyCommand = executeAmplifyCommand;
async function handleAmplifyEvent(context, args) {
    context.print.info(`${constants_1.category} handleAmplifyEvent to be implemented`);
    context.print.info(`Received event args ${args}`);
}
exports.handleAmplifyEvent = handleAmplifyEvent;
//# sourceMappingURL=index.js.map