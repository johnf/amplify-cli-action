"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateConfigOnEnvInit = exports.getPermissionPolicies = exports.migrateResource = exports.updateResource = exports.addResource = exports.importResource = void 0;
const _ = require('lodash');
const amplify_cli_core_1 = require("amplify-cli-core");
const import_s3_1 = require("./import/import-s3");
const import_dynamodb_1 = require("./import/import-dynamodb");
var import_1 = require("./import");
Object.defineProperty(exports, "importResource", { enumerable: true, get: function () { return import_1.importResource; } });
function addResource(context, category, service, options) {
    const serviceMetadata = require('../supported-services').supportedServices[service];
    const { defaultValuesFilename, serviceWalkthroughFilename } = serviceMetadata;
    const serviceWalkthroughSrc = `${__dirname}/service-walkthroughs/${serviceWalkthroughFilename}`;
    const { addWalkthrough } = require(serviceWalkthroughSrc);
    return addWalkthrough(context, defaultValuesFilename, serviceMetadata, options).then(async (resourceName) => {
        context.amplify.updateamplifyMetaAfterResourceAdd(category, resourceName, options);
        return resourceName;
    });
}
exports.addResource = addResource;
function updateResource(context, category, service) {
    const serviceMetadata = require('../supported-services').supportedServices[service];
    const { defaultValuesFilename, serviceWalkthroughFilename } = serviceMetadata;
    const serviceWalkthroughSrc = `${__dirname}/service-walkthroughs/${serviceWalkthroughFilename}`;
    const { updateWalkthrough } = require(serviceWalkthroughSrc);
    if (!updateWalkthrough) {
        const errMessage = 'Update functionality not available for this service';
        context.print.error(errMessage);
        context.usageData.emitError(new amplify_cli_core_1.NotImplementedError(errMessage));
        amplify_cli_core_1.exitOnNextTick(0);
    }
    return updateWalkthrough(context, defaultValuesFilename, serviceMetadata);
}
exports.updateResource = updateResource;
function migrateResource(context, projectPath, service, resourceName) {
    const serviceMetadata = require('../supported-services').supportedServices[service];
    const { serviceWalkthroughFilename } = serviceMetadata;
    const serviceWalkthroughSrc = `${__dirname}/service-walkthroughs/${serviceWalkthroughFilename}`;
    const { migrate } = require(serviceWalkthroughSrc);
    if (!migrate) {
        context.print.info(`No migration required for ${resourceName}`);
        return;
    }
    return migrate(context, projectPath, resourceName);
}
exports.migrateResource = migrateResource;
function getPermissionPolicies(context, service, resourceName, crudOptions) {
    const serviceMetadata = require('../supported-services').supportedServices[service];
    const { serviceWalkthroughFilename } = serviceMetadata;
    const serviceWalkthroughSrc = `${__dirname}/service-walkthroughs/${serviceWalkthroughFilename}`;
    const { getIAMPolicies } = require(serviceWalkthroughSrc);
    if (!getPermissionPolicies) {
        context.print.info(`No policies found for ${resourceName}`);
        return;
    }
    return getIAMPolicies(resourceName, crudOptions);
}
exports.getPermissionPolicies = getPermissionPolicies;
async function updateConfigOnEnvInit(context, category, resourceName, service) {
    const serviceMetadata = require('../supported-services').supportedServices[service];
    const { provider } = serviceMetadata;
    const providerPlugin = context.amplify.getPluginInstance(context, provider);
    const resourceParams = providerPlugin.loadResourceParameters(context, category, resourceName);
    let currentEnvSpecificValues = context.amplify.loadEnvResourceParameters(context, category, resourceName);
    const resource = _.get(context.exeInfo, ['amplifyMeta', category, resourceName]);
    if (resource && resource.serviceType === 'imported') {
        let envSpecificParametersResult;
        const envInitFunction = service === 'S3' ? import_s3_1.importedS3EnvInit : import_dynamodb_1.importedDynamoDBEnvInit;
        const { doServiceWalkthrough, succeeded, envSpecificParameters } = await envInitFunction(context, resourceName, resource, resourceParams, provider, providerPlugin, currentEnvSpecificValues, isInHeadlessMode(context), isInHeadlessMode(context) ? getHeadlessParams(context) : {});
        if (doServiceWalkthrough === true) {
            const importFunction = service === 'S3' ? import_s3_1.importS3 : import_dynamodb_1.importDynamoDB;
            const importResult = await importFunction(context, {
                providerName: provider,
                provider: undefined,
                service,
            }, resourceParams, providerPlugin, false);
            if (importResult) {
                envSpecificParametersResult = importResult.envSpecificParameters;
            }
            else {
                throw new Error('There was an error importing the previously configured storage configuration to the new environment.');
            }
        }
        else if (succeeded) {
            envSpecificParametersResult = envSpecificParameters;
        }
        else {
            throw new Error('There was an error importing the previously configured storage configuration to the new environment.');
        }
        const currentMeta = amplify_cli_core_1.stateManager.getCurrentMeta(undefined, {
            throwIfNotExist: false,
        });
        if (currentMeta) {
            const meta = amplify_cli_core_1.stateManager.getMeta(undefined, {
                throwIfNotExist: false,
            });
            const cloudTimestamp = _.get(currentMeta, [category, resourceName, 'lastPushTimeStamp'], undefined);
            if (cloudTimestamp) {
                resource.lastPushTimeStamp = cloudTimestamp;
            }
            else {
                resource.lastPushTimeStamp = new Date();
            }
            _.set(meta, [category, resourceName, 'lastPushTimeStamp'], cloudTimestamp);
            amplify_cli_core_1.stateManager.setMeta(undefined, meta);
        }
        return envSpecificParametersResult;
    }
}
exports.updateConfigOnEnvInit = updateConfigOnEnvInit;
function isInHeadlessMode(context) {
    return context.exeInfo.inputParams.yes;
}
function getHeadlessParams(context) {
    const { inputParams } = context.exeInfo;
    try {
        const { categories = {} } = typeof inputParams === 'string' ? JSON.parse(inputParams) : inputParams;
        return categories.storage || {};
    }
    catch (err) {
        throw new Error(`Failed to parse storage headless parameters: ${err}`);
    }
}
//# sourceMappingURL=index.js.map