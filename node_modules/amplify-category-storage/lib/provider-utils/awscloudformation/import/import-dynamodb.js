"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importedDynamoDBEnvInit = exports.importDynamoDB = void 0;
const amplify_cli_core_1 = require("amplify-cli-core");
const enquirer_1 = __importDefault(require("enquirer"));
const lodash_1 = __importDefault(require("lodash"));
const messages_1 = require("./messages");
const importDynamoDB = async (context, serviceSelection, previousResourceParameters, providerPluginInstance, printSuccessMessage = true) => {
    const providerPlugin = providerPluginInstance || require(serviceSelection.provider);
    const providerUtils = providerPlugin;
    const importServiceWalkthroughResult = await importServiceWalkthrough(context, serviceSelection.providerName, providerUtils, previousResourceParameters);
    if (!importServiceWalkthroughResult) {
        return;
    }
    const { questionParameters, answers } = importServiceWalkthroughResult;
    const persistEnvParameters = !previousResourceParameters;
    const { envSpecificParameters } = await updateStateFiles(context, questionParameters, answers, persistEnvParameters);
    if (printSuccessMessage) {
        printSuccess(context, answers.tableName);
    }
    return {
        envSpecificParameters,
    };
};
exports.importDynamoDB = importDynamoDB;
const printSuccess = (context, tableName) => {
    context.print.info('');
    context.print.info(`✅ DynamoDB Table '${tableName}' was successfully imported.`);
    context.print.info('');
    context.print.info('Next steps:');
    context.print.info(`- This resource can now be accessed from REST APIs (‘amplify add api’) and Functions (‘amplify add function’)`);
};
const importServiceWalkthrough = async (context, providerName, providerUtils, previousResourceParameters) => {
    const dynamoDB = await providerUtils.createDynamoDBService(context);
    const amplifyMeta = amplify_cli_core_1.stateManager.getMeta();
    const { Region } = amplifyMeta.providers[providerName];
    let tableList = await dynamoDB.listTables();
    const storageResources = Object.values(lodash_1.default.get(amplifyMeta, ['storage'], []));
    const dynamoDBResources = storageResources.filter(r => r.service === 'DynamoDB' && !!r.output && !!r.output.Name).map(r => r.output.Name);
    tableList = tableList.filter(t => !dynamoDBResources.includes(t));
    if (lodash_1.default.isEmpty(tableList)) {
        context.print.info(messages_1.importMessages.NoDynamoDBTablesToImport);
        return;
    }
    const questionParameters = createParameters(providerName, tableList);
    questionParameters.region = Region;
    const defaultAnswers = {
        resourceName: previousResourceParameters === null || previousResourceParameters === void 0 ? void 0 : previousResourceParameters.resourceName,
    };
    const answers = { ...defaultAnswers };
    const enquirer = new enquirer_1.default(undefined, defaultAnswers);
    if (tableList.length === 1) {
        answers.tableName = tableList[0];
        answers.resourceName = answers.tableName.replace(/[\W_]+/g, '');
        answers.tableDescription = await dynamoDB.getTableDetails(answers.tableName);
        context.print.info(messages_1.importMessages.OneTable(answers.tableName));
    }
    else {
        const tableNameQuestion = {
            type: 'autocomplete',
            name: 'tableName',
            message: messages_1.importMessages.TableSelection,
            required: true,
            choices: tableList,
            limit: 5,
            footer: messages_1.importMessages.AutoCompleteFooter,
        };
        const { tableName } = await enquirer.prompt(tableNameQuestion);
        answers.tableName = tableName;
        answers.resourceName = answers.tableName.replace(/[\W_]+/g, '');
        answers.tableDescription = await dynamoDB.getTableDetails(answers.tableName);
    }
    return {
        questionParameters,
        answers,
    };
};
const createParameters = (providerName, tableList) => {
    const questionParameters = {
        providerName,
        tableList,
    };
    return questionParameters;
};
const updateStateFiles = async (context, questionParameters, answers, updateEnvSpecificParameters) => {
    const backendConfiguration = {
        service: 'DynamoDB',
        serviceType: 'imported',
        providerPlugin: questionParameters.providerName,
        dependsOn: [],
    };
    const resourceParameters = {
        resourceName: answers.resourceName,
        serviceType: 'imported',
    };
    amplify_cli_core_1.stateManager.setResourceParametersJson(undefined, 'storage', answers.resourceName, resourceParameters);
    const metaConfiguration = lodash_1.default.clone(backendConfiguration);
    metaConfiguration.output = createMetaOutput(answers, questionParameters);
    context.amplify.updateamplifyMetaAfterResourceAdd('storage', answers.resourceName, metaConfiguration, backendConfiguration, true);
    const envSpecificParameters = createEnvSpecificResourceParameters(answers, questionParameters);
    if (updateEnvSpecificParameters) {
        context.amplify.saveEnvResourceParameters(context, 'storage', answers.resourceName, envSpecificParameters);
    }
    return {
        backendConfiguration,
        resourceParameters,
        metaConfiguration,
        envSpecificParameters,
    };
};
const createMetaOutput = (answers, questionParameters) => {
    var _a, _b, _c, _d;
    const output = {
        Name: answers.tableName,
        Region: questionParameters.region,
        Arn: answers.tableDescription.TableArn,
        StreamArn: answers.tableDescription.LatestStreamArn,
    };
    const hashKey = (_a = answers.tableDescription.KeySchema) === null || _a === void 0 ? void 0 : _a.find(ks => ks.KeyType === 'HASH');
    const sortKeys = (_b = answers.tableDescription.KeySchema) === null || _b === void 0 ? void 0 : _b.filter(ks => ks.KeyType === 'RANGE');
    if (hashKey) {
        const attribute = (_c = answers.tableDescription.AttributeDefinitions) === null || _c === void 0 ? void 0 : _c.find(a => a.AttributeName === hashKey.AttributeName);
        if (attribute) {
            output.PartitionKeyName = hashKey.AttributeName;
            output.PartitionKeyType = attribute.AttributeType;
        }
    }
    if (sortKeys && sortKeys.length > 0) {
        const attribute = (_d = answers.tableDescription.AttributeDefinitions) === null || _d === void 0 ? void 0 : _d.find(a => a.AttributeName === sortKeys[0].AttributeName);
        if (attribute) {
            output.SortKeyName = sortKeys[0].AttributeName;
            output.SortKeyType = attribute.AttributeType;
        }
    }
    return output;
};
const createEnvSpecificResourceParameters = (answers, questionParameters) => {
    var _a, _b, _c, _d;
    const envSpecificResourceParameters = {
        tableName: answers.tableName,
        region: questionParameters.region,
        arn: answers.tableDescription.TableArn,
        streamArn: answers.tableDescription.LatestStreamArn,
    };
    const hashKey = (_a = answers.tableDescription.KeySchema) === null || _a === void 0 ? void 0 : _a.find(ks => ks.KeyType === 'HASH');
    const sortKeys = (_b = answers.tableDescription.KeySchema) === null || _b === void 0 ? void 0 : _b.filter(ks => ks.KeyType === 'RANGE');
    if (hashKey) {
        const attribute = (_c = answers.tableDescription.AttributeDefinitions) === null || _c === void 0 ? void 0 : _c.find(a => a.AttributeName === hashKey.AttributeName);
        if (attribute) {
            envSpecificResourceParameters.partitionKeyName = hashKey.AttributeName;
            envSpecificResourceParameters.partitionKeyType = attribute.AttributeType;
        }
    }
    if (sortKeys && sortKeys.length > 0) {
        const attribute = (_d = answers.tableDescription.AttributeDefinitions) === null || _d === void 0 ? void 0 : _d.find(a => a.AttributeName === sortKeys[0].AttributeName);
        if (attribute) {
            envSpecificResourceParameters.sortKeyName = sortKeys[0].AttributeName;
            envSpecificResourceParameters.sortKeyType = attribute.AttributeType;
        }
    }
    return envSpecificResourceParameters;
};
const importedDynamoDBEnvInit = async (context, resourceName, resource, resourceParameters, providerName, providerUtils, currentEnvSpecificParameters, isInHeadlessMode, headlessParams) => {
    const dynamoDB = await providerUtils.createDynamoDBService(context);
    const amplifyMeta = amplify_cli_core_1.stateManager.getMeta();
    const { Region } = amplifyMeta.providers[providerName];
    const isPulling = context.input.command === 'pull' || (context.input.command === 'env' && context.input.subCommands[0] === 'pull');
    const isEnvAdd = context.input.command === 'env' && context.input.subCommands[0] === 'add';
    if (isInHeadlessMode) {
        return await headlessImport(context, dynamoDB, providerName, resourceName, resource, resourceParameters, headlessParams);
    }
    if (isPulling) {
        const currentMeta = amplify_cli_core_1.stateManager.getCurrentMeta(undefined, {
            throwIfNotExist: false,
        });
        if (currentMeta) {
            const currentResource = lodash_1.default.get(currentMeta, ['storage', resourceName], undefined);
            if (currentResource && currentResource.output) {
                const { Name, Region, Arn, StreamArn, PartitionKeyName, PartitionKeyType, SortKeyName, SortKeyType } = currentResource.output;
                currentEnvSpecificParameters.tableName = Name;
                currentEnvSpecificParameters.region = Region;
                currentEnvSpecificParameters.arn = Arn;
                currentEnvSpecificParameters.streamArn = StreamArn;
                currentEnvSpecificParameters.partitionKeyName = PartitionKeyName;
                currentEnvSpecificParameters.partitionKeyType = PartitionKeyType;
                currentEnvSpecificParameters.sortKeyName = SortKeyName;
                currentEnvSpecificParameters.sortKeyType = SortKeyType;
            }
        }
    }
    else if (isEnvAdd && context.exeInfo.sourceEnvName) {
        const sourceEnvParams = getSourceEnvParameters(context.exeInfo.sourceEnvName, 'storage', resourceName);
        if (sourceEnvParams) {
            const { importExisting } = await enquirer_1.default.prompt({
                name: 'importExisting',
                type: 'confirm',
                message: messages_1.importMessages.ImportPreviousTable(resourceName, sourceEnvParams.tableName, context.exeInfo.sourceEnvName),
                footer: messages_1.importMessages.ImportPreviousResourceFooter,
                initial: true,
                format: (e) => (e ? 'Yes' : 'No'),
            });
            if (!importExisting) {
                return {
                    doServiceWalkthrough: true,
                };
            }
            currentEnvSpecificParameters.tableName = sourceEnvParams.tableName;
            currentEnvSpecificParameters.region = sourceEnvParams.region;
            currentEnvSpecificParameters.arn = sourceEnvParams.arn;
            currentEnvSpecificParameters.streamArn = sourceEnvParams.streamArn;
            currentEnvSpecificParameters.partitionKeyName = sourceEnvParams.partitionKeyName;
            currentEnvSpecificParameters.partitionKeyType = sourceEnvParams.partitionKeyType;
            currentEnvSpecificParameters.sortKeyName = sourceEnvParams.sortKeyName;
            currentEnvSpecificParameters.sortKeyType = sourceEnvParams.sortKeyType;
        }
    }
    if (!(currentEnvSpecificParameters.tableName && currentEnvSpecificParameters.region)) {
        context.print.info(messages_1.importMessages.ImportNewResourceRequired(resourceName));
        return {
            doServiceWalkthrough: true,
        };
    }
    const questionParameters = {
        providerName,
        tableList: [],
        region: Region,
    };
    const answers = {
        resourceName: resourceParameters.resourceName,
        tableName: currentEnvSpecificParameters.tableName,
    };
    const tableExists = await dynamoDB.tableExists(currentEnvSpecificParameters.tableName);
    if (!tableExists) {
        context.print.error(messages_1.importMessages.TableNotFound(currentEnvSpecificParameters.tableName));
        return {
            succeeded: false,
        };
    }
    answers.tableDescription = await dynamoDB.getTableDetails(currentEnvSpecificParameters.tableName);
    const newState = await updateStateFiles(context, questionParameters, answers, false);
    return {
        succeeded: true,
        envSpecificParameters: newState.envSpecificParameters,
    };
};
exports.importedDynamoDBEnvInit = importedDynamoDBEnvInit;
const headlessImport = async (context, dynamoDB, providerName, resourceName, resource, resourceParameters, headlessParams) => {
    const currentEnvSpecificParameters = ensureHeadlessParameters(resourceParameters, headlessParams);
    const amplifyMeta = amplify_cli_core_1.stateManager.getMeta();
    const { Region } = amplifyMeta.providers[providerName];
    const questionParameters = {
        providerName,
        tableList: [],
        region: Region,
    };
    const answers = {
        resourceName: resourceParameters.resourceName,
        tableName: currentEnvSpecificParameters.tableName,
    };
    const tableExists = await dynamoDB.tableExists(currentEnvSpecificParameters.tableName);
    if (!tableExists) {
        throw new Error(messages_1.importMessages.TableNotFound(currentEnvSpecificParameters.tableName));
    }
    answers.tableDescription = await dynamoDB.getTableDetails(currentEnvSpecificParameters.tableName);
    const newState = await updateStateFiles(context, questionParameters, answers, false);
    return {
        succeeded: true,
        envSpecificParameters: newState.envSpecificParameters,
    };
};
const ensureHeadlessParameters = (resourceParameters, headlessParams) => {
    const missingParams = [];
    if (!headlessParams.tables) {
        missingParams.push('tables');
    }
    if (!headlessParams.region) {
        missingParams.push('region');
    }
    if (missingParams.length > 0) {
        throw new Error(`storage headless is missing the following inputParams ${missingParams.join(', ')}`);
    }
    const tableParams = Object.keys(headlessParams.tables).filter(t => t === resourceParameters.resourceName);
    if ((tableParams === null || tableParams === void 0 ? void 0 : tableParams.length) !== 1) {
        throw new Error(`storage headless expected 1 element for resource: ${resourceParameters.resourceName}, but found: ${tableParams.length}`);
    }
    const envSpecificParameters = {
        tableName: headlessParams.tables[tableParams[0]],
        region: headlessParams.region,
    };
    return envSpecificParameters;
};
const getSourceEnvParameters = (envName, categoryName, resourceName) => {
    const teamProviderInfo = amplify_cli_core_1.stateManager.getTeamProviderInfo(undefined, {
        throwIfNotExist: false,
    });
    if (teamProviderInfo) {
        const envParameters = lodash_1.default.get(teamProviderInfo, [envName, 'categories', categoryName, resourceName], undefined);
        return envParameters;
    }
    return undefined;
};
//# sourceMappingURL=import-dynamodb.js.map