"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importedS3EnvInit = exports.importS3 = void 0;
const amplify_cli_core_1 = require("amplify-cli-core");
const enquirer_1 = __importDefault(require("enquirer"));
const lodash_1 = __importDefault(require("lodash"));
const uuid_1 = __importDefault(require("uuid"));
const s3_walkthrough_1 = require("../service-walkthroughs/s3-walkthrough");
const messages_1 = require("./messages");
const importS3 = async (context, serviceSelection, previousResourceParameters, providerPluginInstance, printSuccessMessage = true) => {
    let resourceName = s3_walkthrough_1.resourceAlreadyExists(context);
    if (resourceName && !previousResourceParameters) {
        const errMessage = 'Amazon S3 storage was already added to your project.';
        context.print.warning(errMessage);
        context.usageData.emitError(new amplify_cli_core_1.ResourceAlreadyExistsError(errMessage));
        amplify_cli_core_1.exitOnNextTick(0);
    }
    const providerPlugin = providerPluginInstance || require(serviceSelection.provider);
    const providerUtils = providerPlugin;
    const importServiceWalkthroughResult = await importServiceWalkthrough(context, serviceSelection.providerName, providerUtils, previousResourceParameters);
    if (!importServiceWalkthroughResult) {
        return;
    }
    const { questionParameters, answers } = importServiceWalkthroughResult;
    const persistEnvParameters = !previousResourceParameters;
    const { envSpecificParameters } = await updateStateFiles(context, questionParameters, answers, persistEnvParameters);
    if (printSuccessMessage) {
        printSuccess(context, answers.bucketName);
    }
    return {
        envSpecificParameters,
    };
};
exports.importS3 = importS3;
const printSuccess = (context, bucketName) => {
    context.print.info('');
    context.print.info(`✅ S3 Bucket '${bucketName}' was successfully imported.`);
    context.print.info('');
    context.print.info('Next steps:');
    context.print.info(`- This resource can now be accessed from REST APIs (‘amplify add api’) and Functions (‘amplify add function’)`);
    context.print.info('- Use Amplify Libraries to add, upload, and download objects to your frontend app');
    context.print.info('  - iOS: https://docs.amplify.aws/lib/storage/getting-started/q/platform/ios');
    context.print.info('  - Android: https://docs.amplify.aws/lib/storage/getting-started/q/platform/android');
    context.print.info('  - JavaScript: https://docs.amplify.aws/lib/storage/getting-started/q/platform/js');
};
const importServiceWalkthrough = async (context, providerName, providerUtils, previousResourceParameters) => {
    await ensureAuth(context);
    let authResources = (await context.amplify.getResourceStatus('auth')).allResources.filter((r) => r.service === 'Cognito');
    if (authResources.length === 0) {
        throw new Error('No auth resource found. Please add it using amplify add auth');
    }
    const s3 = await providerUtils.createS3Service(context);
    const bucketList = await s3.listBuckets();
    if (lodash_1.default.isEmpty(bucketList)) {
        context.print.info(messages_1.importMessages.NoS3BucketsToImport);
        return;
    }
    const questionParameters = createParameters(providerName, bucketList);
    const projectConfig = context.amplify.getProjectConfig();
    const [shortId] = uuid_1.default().split('-');
    const projectName = projectConfig.projectName.toLowerCase().replace(/[^A-Za-z0-9_]+/g, '_');
    const defaultAnswers = {
        resourceName: (previousResourceParameters === null || previousResourceParameters === void 0 ? void 0 : previousResourceParameters.resourceName) || `${projectName}${shortId}`,
    };
    const answers = { ...defaultAnswers };
    const enquirer = new enquirer_1.default(undefined, defaultAnswers);
    if (bucketList.length === 1) {
        answers.bucketName = bucketList[0].Name;
        context.print.info(messages_1.importMessages.OneBucket(answers.bucketName));
    }
    else {
        const bucketNameList = bucketList.map(b => b.Name);
        const bucketNameQuestion = {
            type: 'autocomplete',
            name: 'bucketName',
            message: messages_1.importMessages.BucketSelection,
            required: true,
            choices: bucketNameList,
            limit: 5,
            footer: messages_1.importMessages.AutoCompleteFooter,
        };
        const { bucketName } = await enquirer.prompt(bucketNameQuestion);
        answers.bucketName = bucketName;
    }
    questionParameters.region = await s3.getBucketLocation(answers.bucketName);
    return {
        questionParameters,
        answers,
    };
};
const ensureAuth = async (context) => {
    while (!s3_walkthrough_1.checkIfAuthExists(context)) {
        const addOrImportQuestion = {
            type: 'select',
            name: 'addOrImport',
            message: 'Do you want to add or import auth now?',
            required: true,
            choices: [
                {
                    message: 'Add auth',
                    value: 'add',
                },
                {
                    message: 'Import auth',
                    value: 'import',
                },
                {
                    message: 'Cancel import storage',
                    value: 'cancel',
                },
            ],
            header: 'You need to add auth (Amazon Cognito) to your project in order to add storage for user files.',
        };
        const addOrImportAnswer = await enquirer_1.default.prompt(addOrImportQuestion);
        if (addOrImportAnswer.addOrImport === 'cancel') {
            context.print.info('');
            context.usageData.emitSuccess();
            amplify_cli_core_1.exitOnNextTick(0);
        }
        else {
            try {
                if (addOrImportAnswer.addOrImport === 'add') {
                    await context.amplify.invokePluginMethod(context, 'auth', null, 'add', [context]);
                }
                else {
                    await context.amplify.invokePluginMethod(context, 'auth', null, 'importAuth', [context]);
                }
            }
            catch (e) {
                context.print.error('The Auth plugin is not installed in the CLI. You need to install it to use this feature');
                context.usageData.emitError(e);
                amplify_cli_core_1.exitOnNextTick(1);
            }
        }
    }
};
const createParameters = (providerName, bucketList) => {
    const questionParameters = {
        providerName,
        bucketList,
    };
    return questionParameters;
};
const updateStateFiles = async (context, questionParameters, answers, updateEnvSpecificParameters) => {
    const backendConfiguration = {
        service: 'S3',
        serviceType: 'imported',
        providerPlugin: questionParameters.providerName,
        dependsOn: [],
    };
    const resourceParameters = {
        resourceName: answers.resourceName,
        serviceType: 'imported',
    };
    amplify_cli_core_1.stateManager.setResourceParametersJson(undefined, 'storage', answers.resourceName, resourceParameters);
    const metaConfiguration = lodash_1.default.clone(backendConfiguration);
    metaConfiguration.output = createMetaOutput(answers, questionParameters);
    context.amplify.updateamplifyMetaAfterResourceAdd('storage', answers.resourceName, metaConfiguration, backendConfiguration, true);
    const envSpecificParameters = createEnvSpecificResourceParameters(answers, questionParameters);
    if (updateEnvSpecificParameters) {
        context.amplify.saveEnvResourceParameters(context, 'storage', answers.resourceName, envSpecificParameters);
    }
    return {
        backendConfiguration,
        resourceParameters,
        metaConfiguration,
        envSpecificParameters,
    };
};
const createMetaOutput = (answers, questionParameters) => {
    const output = {
        BucketName: answers.bucketName,
        Region: questionParameters.region,
    };
    return output;
};
const createEnvSpecificResourceParameters = (answers, questionParameters) => {
    const envSpecificResourceParameters = {
        bucketName: answers.bucketName,
        region: questionParameters.region,
    };
    return envSpecificResourceParameters;
};
const importedS3EnvInit = async (context, resourceName, resource, resourceParameters, providerName, providerUtils, currentEnvSpecificParameters, isInHeadlessMode, headlessParams) => {
    const s3 = await providerUtils.createS3Service(context);
    const isPulling = context.input.command === 'pull' || (context.input.command === 'env' && context.input.subCommands[0] === 'pull');
    const isEnvAdd = context.input.command === 'env' && context.input.subCommands[0] === 'add';
    if (isInHeadlessMode) {
        return await headlessImport(context, s3, providerName, resourceName, resource, resourceParameters, headlessParams);
    }
    if (isPulling) {
        const currentMeta = amplify_cli_core_1.stateManager.getCurrentMeta(undefined, {
            throwIfNotExist: false,
        });
        if (currentMeta) {
            const currentResource = lodash_1.default.get(currentMeta, ['storage', resourceName], undefined);
            if (currentResource && currentResource.output) {
                const { BucketName, Region } = currentResource.output;
                currentEnvSpecificParameters.bucketName = BucketName;
                currentEnvSpecificParameters.region = Region;
            }
        }
    }
    else if (isEnvAdd && context.exeInfo.sourceEnvName) {
        const sourceEnvParams = getSourceEnvParameters(context.exeInfo.sourceEnvName, 'storage', resourceName);
        if (sourceEnvParams) {
            const { importExisting } = await enquirer_1.default.prompt({
                name: 'importExisting',
                type: 'confirm',
                message: messages_1.importMessages.ImportPreviousBucket(resourceName, sourceEnvParams.bucketName, context.exeInfo.sourceEnvName),
                footer: messages_1.importMessages.ImportPreviousResourceFooter,
                initial: true,
                format: (e) => (e ? 'Yes' : 'No'),
            });
            if (!importExisting) {
                return {
                    doServiceWalkthrough: true,
                };
            }
            currentEnvSpecificParameters.bucketName = sourceEnvParams.bucketName;
            currentEnvSpecificParameters.region = sourceEnvParams.region;
        }
    }
    if (!(currentEnvSpecificParameters.bucketName && currentEnvSpecificParameters.region)) {
        context.print.info(messages_1.importMessages.ImportNewResourceRequired(resourceName));
        return {
            doServiceWalkthrough: true,
        };
    }
    const questionParameters = {
        providerName,
        bucketList: [],
    };
    const answers = {
        resourceName: resourceParameters.resourceName,
        bucketName: currentEnvSpecificParameters.bucketName,
    };
    const bucketExists = await s3.bucketExists(currentEnvSpecificParameters.bucketName);
    if (!bucketExists) {
        context.print.error(messages_1.importMessages.BucketNotFound(currentEnvSpecificParameters.bucketName));
        return {
            succeeded: false,
        };
    }
    questionParameters.region = await s3.getBucketLocation(answers.bucketName);
    const newState = await updateStateFiles(context, questionParameters, answers, false);
    return {
        succeeded: true,
        envSpecificParameters: newState.envSpecificParameters,
    };
};
exports.importedS3EnvInit = importedS3EnvInit;
const headlessImport = async (context, s3, providerName, resourceName, resource, resourceParameters, headlessParams) => {
    const currentEnvSpecificParameters = ensureHeadlessParameters(resourceParameters, headlessParams);
    const amplifyMeta = amplify_cli_core_1.stateManager.getMeta();
    const questionParameters = {
        providerName,
        bucketList: [],
    };
    const answers = {
        resourceName: resourceParameters.resourceName,
        bucketName: currentEnvSpecificParameters.bucketName,
    };
    const bucketExists = await s3.bucketExists(currentEnvSpecificParameters.bucketName);
    if (!bucketExists) {
        throw new Error(messages_1.importMessages.BucketNotFound(currentEnvSpecificParameters.bucketName));
    }
    questionParameters.region = await s3.getBucketLocation(answers.bucketName);
    const newState = await updateStateFiles(context, questionParameters, answers, false);
    return {
        succeeded: true,
        envSpecificParameters: newState.envSpecificParameters,
    };
};
const ensureHeadlessParameters = (resourceParameters, headlessParams) => {
    const missingParams = [];
    if (!headlessParams.bucketName) {
        missingParams.push('bucketName');
    }
    if (!headlessParams.region) {
        missingParams.push('region');
    }
    if (missingParams.length > 0) {
        throw new Error(`storage headless is missing the following inputParams ${missingParams.join(', ')}`);
    }
    const envSpecificParameters = {
        bucketName: headlessParams.bucketName,
        region: headlessParams.region,
    };
    return envSpecificParameters;
};
const getSourceEnvParameters = (envName, categoryName, resourceName) => {
    const teamProviderInfo = amplify_cli_core_1.stateManager.getTeamProviderInfo(undefined, {
        throwIfNotExist: false,
    });
    if (teamProviderInfo) {
        const envParameters = lodash_1.default.get(teamProviderInfo, [envName, 'categories', categoryName, resourceName], undefined);
        return envParameters;
    }
    return undefined;
};
//# sourceMappingURL=import-s3.js.map