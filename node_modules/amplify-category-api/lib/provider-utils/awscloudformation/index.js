"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPermissionPolicies = exports.addDatasource = exports.migrateResource = exports.updateResource = exports.addResource = exports.console = void 0;
const service_walkthrough_result_to_add_api_request_1 = require("./utils/service-walkthrough-result-to-add-api-request");
const cfn_api_artifact_handler_1 = require("./cfn-api-artifact-handler");
const dynamic_imports_1 = require("./utils/dynamic-imports");
const legacy_add_resource_1 = require("./legacy-add-resource");
const legacy_update_resource_1 = require("./legacy-update-resource");
const edit_schema_flow_1 = require("./utils/edit-schema-flow");
const amplify_cli_core_1 = require("amplify-cli-core");
const containers_handler_1 = require("./containers-handler");
const inquirer_1 = __importDefault(require("inquirer"));
const containers_walkthrough_1 = require("./service-walkthroughs/containers-walkthrough");
const category_constants_1 = require("../../category-constants");
async function console(context, service) {
    const { serviceWalkthroughFilename } = await dynamic_imports_1.serviceMetadataFor(service);
    const serviceWalkthroughSrc = `${__dirname}/service-walkthroughs/${serviceWalkthroughFilename}`;
    const { openConsole } = require(serviceWalkthroughSrc);
    if (!openConsole) {
        const errMessage = 'Opening console functionality not available for this option';
        context.print.error(errMessage);
        await context.usageData.emitError(new amplify_cli_core_1.NotImplementedError(errMessage));
        amplify_cli_core_1.exitOnNextTick(0);
    }
    return openConsole(context);
}
exports.console = console;
async function addContainerResource(context, category, service, options, apiType) {
    const serviceWalkthroughFilename = 'containers-walkthrough.js';
    const defaultValuesFilename = 'containers-defaults.js';
    const serviceWalkthrough = await dynamic_imports_1.getServiceWalkthrough(serviceWalkthroughFilename);
    const serviceWalkthroughPromise = serviceWalkthrough(context, defaultValuesFilename, apiType);
    return await containers_handler_1.addResource(serviceWalkthroughPromise, context, category, service, options, apiType);
}
async function addNonContainerResource(context, category, service, options) {
    const serviceMetadata = await dynamic_imports_1.serviceMetadataFor(service);
    const { serviceWalkthroughFilename, defaultValuesFilename } = serviceMetadata;
    const serviceWalkthrough = await dynamic_imports_1.getServiceWalkthrough(serviceWalkthroughFilename);
    const serviceWalkthroughPromise = serviceWalkthrough(context, defaultValuesFilename, serviceMetadata);
    switch (service) {
        case 'AppSync':
            const walkthroughResult = await serviceWalkthroughPromise;
            const askToEdit = walkthroughResult.askToEdit;
            const apiName = await cfn_api_artifact_handler_1.getCfnApiArtifactHandler(context).createArtifacts(service_walkthrough_result_to_add_api_request_1.serviceWalkthroughResultToAddApiRequest(walkthroughResult));
            if (askToEdit) {
                await edit_schema_flow_1.editSchemaFlow(context, apiName);
            }
            return apiName;
        default:
            return legacy_add_resource_1.legacyAddResource(serviceWalkthroughPromise, context, category, service, options);
    }
}
async function addResource(context, category, service, options) {
    let useContainerResource = false;
    let apiType = containers_walkthrough_1.API_TYPE.GRAPHQL;
    if (isContainersEnabled(context)) {
        switch (service) {
            case 'AppSync':
                useContainerResource = await isGraphQLContainer(context);
                apiType = containers_walkthrough_1.API_TYPE.GRAPHQL;
                break;
            case 'API Gateway':
                useContainerResource = await isRestContainer(context);
                apiType = containers_walkthrough_1.API_TYPE.REST;
                break;
            default:
                throw new Error(`${service} not exists`);
        }
    }
    return useContainerResource
        ? addContainerResource(context, category, service, options, apiType)
        : addNonContainerResource(context, category, service, options);
}
exports.addResource = addResource;
function isContainersEnabled(context) {
    const { frontend } = context.amplify.getProjectConfig();
    if (frontend) {
        const { config: { ServerlessContainers = false } = {} } = context.amplify.getProjectConfig()[frontend] || {};
        return ServerlessContainers;
    }
    return false;
}
async function isGraphQLContainer(context) {
    const { graphqlSelection } = await inquirer_1.default.prompt({
        name: 'graphqlSelection',
        message: 'Which service would you like to use',
        type: 'list',
        choices: [
            {
                name: 'AppSync',
                value: false,
            },
            {
                name: 'AWS Fargate (Container-based)',
                value: true,
            },
        ],
    });
    return graphqlSelection;
}
async function isRestContainer(context) {
    const { restSelection } = await inquirer_1.default.prompt({
        name: 'restSelection',
        message: 'Which service would you like to use',
        type: 'list',
        choices: [
            {
                name: 'API Gateway + Lambda',
                value: false,
            },
            {
                name: 'API Gateway + AWS Fargate (Container-based)',
                value: true,
            },
        ],
    });
    return restSelection;
}
async function updateResource(context, category, service, options) {
    let useContainerResource = false;
    let apiType = containers_walkthrough_1.API_TYPE.GRAPHQL;
    if (isContainersEnabled(context)) {
        const { hasAPIGatewayContainerResource, hasAPIGatewayLambdaResource, hasGraphQLAppSyncResource, hasGraphqlContainerResource, } = await describeApiResourcesBySubCategory(context);
        switch (service) {
            case 'AppSync':
                if (hasGraphQLAppSyncResource && hasGraphqlContainerResource) {
                    useContainerResource = await isGraphQLContainer(context);
                }
                else if (hasGraphqlContainerResource) {
                    useContainerResource = true;
                }
                else {
                    useContainerResource = false;
                }
                apiType = containers_walkthrough_1.API_TYPE.GRAPHQL;
                break;
            case 'API Gateway':
                if (hasAPIGatewayContainerResource && hasAPIGatewayLambdaResource) {
                    useContainerResource = await isRestContainer(context);
                }
                else if (hasAPIGatewayContainerResource) {
                    useContainerResource = true;
                }
                else {
                    useContainerResource = false;
                }
                apiType = containers_walkthrough_1.API_TYPE.REST;
                break;
            default:
                throw new Error(`${service} not exists`);
        }
    }
    return useContainerResource
        ? updateContainerResource(context, category, service, apiType)
        : updateNonContainerResource(context, category, service);
}
exports.updateResource = updateResource;
async function describeApiResourcesBySubCategory(context) {
    const { allResources } = await context.amplify.getResourceStatus();
    const resources = allResources.filter(resource => resource.category === category_constants_1.category && resource.mobileHubMigrated !== true);
    let hasAPIGatewayContainerResource = false;
    let hasAPIGatewayLambdaResource = false;
    let hasGraphQLAppSyncResource = false;
    let hasGraphqlContainerResource = false;
    resources.forEach(resource => {
        hasAPIGatewayContainerResource =
            hasAPIGatewayContainerResource || (resource.service === 'ElasticContainer' && resource.apiType === containers_walkthrough_1.API_TYPE.REST);
        hasAPIGatewayLambdaResource = hasAPIGatewayLambdaResource || resource.service === 'API Gateway';
        hasGraphQLAppSyncResource = hasGraphQLAppSyncResource || resource.service === 'AppSync';
        hasGraphqlContainerResource =
            hasGraphqlContainerResource || (resource.service === 'ElasticContainer' && resource.apiType === containers_walkthrough_1.API_TYPE.GRAPHQL);
    });
    return {
        hasAPIGatewayLambdaResource,
        hasAPIGatewayContainerResource,
        hasGraphQLAppSyncResource,
        hasGraphqlContainerResource,
    };
}
async function updateContainerResource(context, category, service, apiType) {
    const serviceWalkthroughFilename = 'containers-walkthrough';
    const defaultValuesFilename = 'containers-defaults.js';
    const serviceWalkthroughSrc = `${__dirname}/service-walkthroughs/${serviceWalkthroughFilename}`;
    const { updateWalkthrough } = require(serviceWalkthroughSrc);
    if (!updateWalkthrough) {
        const errMessage = 'Update functionality not available for this option';
        context.print.error(errMessage);
        await context.usageData.emitError(new amplify_cli_core_1.NotImplementedError(errMessage));
        amplify_cli_core_1.exitOnNextTick(0);
    }
    const updateWalkthroughPromise = updateWalkthrough(context, defaultValuesFilename, apiType);
    containers_handler_1.updateResource(updateWalkthroughPromise, context, category);
}
async function updateNonContainerResource(context, category, service) {
    const serviceMetadata = await dynamic_imports_1.serviceMetadataFor(service);
    const { defaultValuesFilename, serviceWalkthroughFilename } = serviceMetadata;
    const serviceWalkthroughSrc = `${__dirname}/service-walkthroughs/${serviceWalkthroughFilename}`;
    const { updateWalkthrough } = require(serviceWalkthroughSrc);
    if (!updateWalkthrough) {
        const errMessage = 'Update functionality not available for this option';
        context.print.error(errMessage);
        await context.usageData.emitError(new amplify_cli_core_1.NotImplementedError(errMessage));
        amplify_cli_core_1.exitOnNextTick(0);
    }
    const updateWalkthroughPromise = updateWalkthrough(context, defaultValuesFilename, serviceMetadata);
    switch (service) {
        case 'AppSync':
            return updateWalkthroughPromise.then(cfn_api_artifact_handler_1.getCfnApiArtifactHandler(context).updateArtifacts);
        default:
            return legacy_update_resource_1.legacyUpdateResource(updateWalkthroughPromise, context, category, service);
    }
}
async function migrateResource(context, projectPath, service, resourceName) {
    if (service === 'ElasticContainer') {
        return migrateResourceContainer(context, projectPath, service, resourceName);
    }
    else {
        return migrateResourceNonContainer(context, projectPath, service, resourceName);
    }
}
exports.migrateResource = migrateResource;
async function migrateResourceContainer(context, projectPath, service, resourceName) {
    context.print.info(`No migration required for ${resourceName}`);
    return;
}
async function migrateResourceNonContainer(context, projectPath, service, resourceName) {
    const serviceMetadata = await dynamic_imports_1.serviceMetadataFor(service);
    const { serviceWalkthroughFilename } = serviceMetadata;
    const serviceWalkthroughSrc = `${__dirname}/service-walkthroughs/${serviceWalkthroughFilename}`;
    const { migrate } = require(serviceWalkthroughSrc);
    if (!migrate) {
        context.print.info(`No migration required for ${resourceName}`);
        return;
    }
    return await migrate(context, projectPath, resourceName);
}
async function addDatasource(context, category, datasource) {
    const serviceMetadata = await dynamic_imports_1.datasourceMetadataFor(datasource);
    const { defaultValuesFilename, serviceWalkthroughFilename } = serviceMetadata;
    return (await dynamic_imports_1.getServiceWalkthrough(serviceWalkthroughFilename))(context, defaultValuesFilename, serviceMetadata);
}
exports.addDatasource = addDatasource;
async function getPermissionPolicies(context, service, resourceName, crudOptions) {
    if (service === 'ElasticContainer') {
        return getPermissionPoliciesContainer(context, service, resourceName, crudOptions);
    }
    else {
        return getPermissionPoliciesNonContainer(context, service, resourceName, crudOptions);
    }
}
exports.getPermissionPolicies = getPermissionPolicies;
async function getPermissionPoliciesContainer(context, service, resourceName, crudOptions) {
    return containers_walkthrough_1.getPermissionPolicies(context, service, resourceName, crudOptions);
}
async function getPermissionPoliciesNonContainer(context, service, resourceName, crudOptions) {
    const serviceMetadata = await dynamic_imports_1.serviceMetadataFor(service);
    const { serviceWalkthroughFilename } = serviceMetadata;
    const serviceWalkthroughSrc = `${__dirname}/service-walkthroughs/${serviceWalkthroughFilename}`;
    const { getIAMPolicies } = require(serviceWalkthroughSrc);
    if (!getIAMPolicies) {
        context.print.info(`No policies found for ${resourceName}`);
        return;
    }
    return getIAMPolicies(resourceName, crudOptions, context);
}
//# sourceMappingURL=index.js.map